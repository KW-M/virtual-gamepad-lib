var D=Object.defineProperty,M=Object.defineProperties;var O=Object.getOwnPropertyDescriptors;var C=Object.getOwnPropertySymbols;var T=Object.prototype.hasOwnProperty,B=Object.prototype.propertyIsEnumerable;var E=(d,e,t)=>e in d?D(d,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):d[e]=t,x=(d,e)=>{for(var t in e||(e={}))T.call(e,t)&&E(d,t,e[t]);if(C)for(var t of C(e))B.call(e,t)&&E(d,t,e[t]);return d},P=(d,e)=>M(d,O(e));var h=(d,e,t)=>E(d,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const r of s.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&n(r)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();var g=(d=>(d.up="up",d.down="down",d.left="left",d.right="right",d))(g||{}),b=(d=>(d.onOff="onOff",d.variable="variable",d))(b||{}),G=(d=>(d.real="real",d.emulated="emulated",d.overlay="overlay",d))(G||{});function S(d,e,t){const n=Math.sqrt(d*d+e*e);return n>t?{x:d/n,y:e/n}:{x:d/t,y:e/t}}function R(d){if(d instanceof SVGGraphicsElement){d.getAttribute("transform")&&console.warn("VirtualGamepadLib: Setting Transform origin on an element that already has a transform attribute. This may break the transform!",d);const e=d.getBBox();d.style.transformOrigin=`${e.x+e.width/2}px ${e.y+e.height/2}px`}else if(d instanceof HTMLElement){console.warn("VirtualGamepadLib: Setting Transform origin on an element that is not an SVG element. This may break the transform!",d);const e=d.getBoundingClientRect();d.style.transformOrigin=`${e.width/2}px ${e.height/2}px`}}const k=18,F=4,w=class w{constructor(e){h(this,"getNativeGamepads");h(this,"buttonPressThreshold",.1);h(this,"realGpadToPatchedIndexMap",[]);h(this,"patchedGpadToRealIndexMap",[]);h(this,"emulatedGamepads",[]);h(this,"emulatedGamepadsMetadata",[]);h(this,"undoEventPatch",()=>{});if(this.buttonPressThreshold=e||this.buttonPressThreshold,w.instanceRunning)throw new Error("Only one GamepadEmulator instance may exist at a time!");w.instanceRunning=!0,this.undoEventPatch=this.monkeyPatchGamepadEvents(),this.monkeyPatchGetGamepads()}gamepadApiNativelySupported(){return!!this.getNativeGamepads&&!!this.getNativeGamepads.apply(navigator)}AddEmulatedGamepad(e,t,n=k,i=F){if((e===-1||!e&&e!==0)&&(e=this.nextEmptyEGpadIndex(t)),this.emulatedGamepads[e])return!1;const s={emulation:G.emulated,connected:!0,timestamp:performance.now(),displayId:"Emulated Gamepad "+e,id:"Emulated Gamepad "+e+" (Xinput STANDARD GAMEPAD)",mapping:"standard",index:e,buttons:new Array(n).fill({pressed:!1,value:0,touched:!1},0,n),axes:new Array(i).fill(0,0,i),hapticActuators:[]};this.emulatedGamepads[e]=s,this.emulatedGamepadsMetadata[e]={overlayMode:t};const r=new Event("gamepadconnected");return r.gamepad=s,window.dispatchEvent(r),s}RemoveEmulatedGamepad(e){this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);var t=this.emulatedGamepads[e];if(t){delete this.emulatedGamepads[e],delete this.emulatedGamepadsMetadata[e];const n=P(x({},t),{connected:!1,timestamp:performance.now()}),i=new Event("gamepaddisconnected");i.gamepad=n,window.dispatchEvent(i)}else console.warn("GamepadEmulator Error: Cannot remove emulated gamepad. No emulated gamepad exists at index "+e)}PressButton(e,t,n,i){if(this.emulatedGamepads[e]===void 0)throw new Error("Error: PressButton() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");var s=n>this.buttonPressThreshold;this.emulatedGamepads[e].buttons[t]={pressed:s,value:n||0,touched:s||i||!1}}MoveAxis(e,t,n){if(!this.emulatedGamepads[e])throw new Error("Error: MoveAxis() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");this.emulatedGamepads[e].axes[t]=n}AddDisplayButtonEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let n=[];for(var i=0;i<t.length;i++){const s=t[i],r=s.buttonIndex,a=s.tapTarget;if(!a){console.warn("GamepadEmulator: No tap target in gamepad "+e+" display config for button "+r+", skipping...");continue}const o=l=>{l.changedTouches[0].target==a&&l.preventDefault()};window.addEventListener("touchstart",o,{passive:!1});const p=l=>{const u=l.buttons==1?1:0;(!s.lockTargetWhilePressed||u==0)&&this.PressButton(e,r,u,!0)};a.addEventListener("pointerenter",p);const m=l=>{const u=l.buttons==1?1:0;(!s.lockTargetWhilePressed||u==0)&&this.PressButton(e,r,0,!1)};a.addEventListener("pointerleave",m);const c=l=>{};if(a.addEventListener("pointercancel",c),s.type==b.onOff){const l=f=>{f.preventDefault(),this.PressButton(e,r,1,!0),s.lockTargetWhilePressed?a.setPointerCapture(f.pointerId):a.releasePointerCapture(f.pointerId)};a.addEventListener("pointerdown",l);const u=()=>{this.PressButton(e,r,0,!0)};a.addEventListener("pointerup",u),n.push(function(){window.removeEventListener("touchstart",o),a.removeEventListener("pointerenter",p),a.removeEventListener("pointerleave",m),a.removeEventListener("pointerdown",l),a.removeEventListener("pointerup",u),a.removeEventListener("pointercancel",c)})}else if(s.type==b.variable){const l=x({},s),u=this.AddDragControlListener(l,(f,y,L)=>{let v=f?this.buttonPressThreshold+1e-5:0;v+=s.directions[g.left]||s.directions[g.right]?Math.abs(y):0,v+=s.directions[g.up]||s.directions[g.down]?Math.abs(L):0,this.PressButton(e,s.buttonIndex,Math.min(v,1),f)});n.push(function(){window.removeEventListener("touchstart",o),a.removeEventListener("pointerenter",p),a.removeEventListener("pointerleave",m),a.removeEventListener("pointercancel",c),u()})}}this.emulatedGamepadsMetadata[e].removeButtonListenersFunc=()=>{n.forEach(s=>s())}}AddDisplayJoystickEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let n=[];for(let i=0;i<t.length;i++){const s=t[i];if(s.tapTarget==null){console.warn("GamepadEmulator: No tap target in gamepad "+e+" display config for joystick "+i+", skipping...");continue}const r=this.AddDragControlListener(s,(a,o,p)=>{s.xAxisIndex!==void 0&&this.MoveAxis(e,s.xAxisIndex,o),s.yAxisIndex!==void 0&&this.MoveAxis(e,s.yAxisIndex,p)});n.push(r)}this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc=()=>{n.forEach(i=>i())}}ClearDisplayButtonEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])!=null&&t.removeButtonListenersFunc)&&this.emulatedGamepadsMetadata[e].removeButtonListenersFunc()}ClearDisplayJoystickEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])!=null&&t.removeJoystickListenersFunc)&&this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc()}AddDragControlListener(e,t){let n={startX:0,startY:0},i=-1;const s=o=>{var p=o.pointerId;if(i===p){const m=e.directions[g.left]?-1:0,c=e.directions[g.right]?1:0,l=e.directions[g.up]?-1:0,u=e.directions[g.down]?1:0,f=o.clientX-n.startX,y=o.clientY-n.startY;let{x:L,y:v}=S(f,y,e.dragDistance);L=Math.max(Math.min(L,c),m),v=Math.max(Math.min(v,u),l),t(!0,L,v)}},r=o=>{i==o.pointerId&&(document.removeEventListener("pointermove",s,!1),document.removeEventListener("pointerup",r,!1),i=-1,t(!1,0,0))};e.tapTarget.addEventListener("pointerdown",o=>{o.preventDefault(),n.startX=o.clientX,n.startY=o.clientY,i=o.pointerId,e.lockTargetWhilePressed?e.tapTarget.setPointerCapture(o.pointerId):e.tapTarget.releasePointerCapture(o.pointerId),t(!0,0,0),document.addEventListener("pointermove",s,!1),document.addEventListener("pointerup",r,!1)});const a=o=>{o.changedTouches[0].target==e.tapTarget&&o.preventDefault()};return window.addEventListener("touchstart",a,{passive:!1}),function(){window.removeEventListener("touchstart",a),e.tapTarget.removeEventListener("pointerdown",s)}}cloneGamepad(e){if(!e)return e;const t=e.axes?e.axes.length:0,n=e.buttons?e.buttons.length:0,i={};for(let s in e)if(s==="axes"){const r=new Array(t);for(let a=0;a<t;a++)r[a]=Number(e.axes[a]);Object.defineProperty(i,"axes",{value:r,enumerable:!0})}else if(s==="buttons"){const r=new Array(n);for(let a=0;a<n;a++){const o=e.buttons[a];if(o==null)r[a]=o;else{const p=o.pressed,m=o.value,c=o.touched||!1;r[a]={pressed:p,value:m,touched:c}}}Object.defineProperty(i,"buttons",{value:r,enumerable:!0})}else Object.defineProperty(i,s,{get:()=>e[s],configurable:!0,enumerable:!0});return i.emulation||(i.emulation=G.real),i}nextEmptyEGpadIndex(e){let t=0;if(e)do{if(!this.emulatedGamepads[t])break;t++}while(t<this.emulatedGamepads.length);else{const n=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{if(!this.emulatedGamepads[t]&&this.patchedGpadToRealIndexMap[t]==null)break;t++}while(t<n)}return t}nextEmptyRealGpadIndex(e){let t=e;const n=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{const i=this.emulatedGamepadsMetadata[t],s=this.realGpadToPatchedIndexMap[t]==null&&this.patchedGpadToRealIndexMap[t]==null;if(i&&i.overlayMode||!i&&s)break;t++}while(t<n);return t}monkeyPatchGamepadEvents(){let e,t,n,i;window.hasOwnProperty("ongamepadconnected")&&(e=Object.getOwnPropertyDescriptor(window,"ongamepadconnected"),n=window.ongamepadconnected,window.ongamepadconnected=null,Object.defineProperty(window,"ongamepadconnected",{get:()=>function(a){},set:a=>{n=a},configurable:!0})),window.hasOwnProperty("ongamepaddisconnected")&&(t=Object.getOwnPropertyDescriptor(window,"ongamepaddisconnected"),i=window.ongamepaddisconnected,window.ongamepaddisconnected=null,Object.defineProperty(window,"ongamepaddisconnected",{get:()=>function(a){},set:a=>{n=a},configurable:!0}));const s=a=>{const o=a.gamepad;if(o&&o.emulation===void 0){a.stopImmediatePropagation();const p=this.cloneGamepad(a.gamepad),m=p.index,c=this.nextEmptyRealGpadIndex(m);this.realGpadToPatchedIndexMap[m]=c,this.patchedGpadToRealIndexMap[c]=m,Object.defineProperty(p,"index",{get:()=>c}),Object.defineProperty(p,"emulation",{get:()=>G.real});const l=new Event("gamepadconnected");l.gamepad=p,window.dispatchEvent(l)}n&&n.call(window,a)};window.addEventListener("gamepadconnected",s);const r=a=>{const o=a.gamepad;if(o&&o.emulation===void 0){a.stopImmediatePropagation();const p=this.cloneGamepad(a.gamepad),m=this.realGpadToPatchedIndexMap[p.index]||p.index;Object.defineProperty(p,"index",{get:()=>m}),delete this.realGpadToPatchedIndexMap[p.index],delete this.patchedGpadToRealIndexMap[m];const c=new Event("gamepaddisconnected");c.gamepad=p,window.dispatchEvent(a)}i&&i.call(window,a)};return window.addEventListener("gamepaddisconnected",r),function(){window.removeEventListener("gamepadconnected",s),window.hasOwnProperty("ongamepadconnected")&&(Object.defineProperty(window,"ongamepadconnected",e),window.ongamepadconnected=n),window.removeEventListener("gamepaddisconnected",r),window.hasOwnProperty("ongamepaddisconnected")&&(Object.defineProperty(window,"ongamepaddisconnected",t),window.ongamepaddisconnected=i)}}monkeyPatchGetGamepads(){const e=this;let t=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads;this.getNativeGamepads=t,navigator.getNativeGamepads=t,navigator.getGamepads=function(){let n=[],i=t!=null?t.apply(navigator)||[]:[];for(let r=0;r<i.length;r++){const a=i[r];if(!a)continue;let o=e.cloneGamepad(a),p=e.realGpadToPatchedIndexMap[o.index]||o.index;Object.defineProperty(o,"index",{get:()=>p}),n[p]=o}let s=e.emulatedGamepads;for(let r=0;r<s.length;r++){let a=n[r],o=s[r];if(o&&a){a.emulation=G.overlay;let p=Math.max(a.buttons.length,o.buttons.length);for(let c=0;c<p;c++){const l=o.buttons[c]||{touched:!1,pressed:!1,value:0},u=a.buttons[c]||{touched:!1,pressed:!1,value:0};n[r].buttons[c]={touched:l.touched||u.touched||!1,pressed:l.pressed||u.pressed||!1,value:Math.max(l.value,u.value)||0}}let m=Math.max(o.axes.length,a.axes.length);for(let c=0;c<m;c++){const l=o.axes[c]||0,u=a.axes[c]||0;n[r].axes[c]=Math.abs(l||0)>Math.abs(u||0)?l||0:u||0}}else o&&(o.emulation=G.emulated,o.timestamp=performance.now(),n[r]=e.cloneGamepad(o))}return n}}cleanup(){for(let e=0;e<this.emulatedGamepads.length;e++)this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);this.emulatedGamepads=[],this.undoEventPatch(),this.getNativeGamepads?navigator.getGamepads=this.getNativeGamepads:Object.defineProperty(navigator,"getGamepads",{value:void 0,configurable:!0}),w.instanceRunning=!1,delete navigator.getNativeGamepads}};h(w,"instanceRunning",!1);let A=w;class j{constructor(e){h(this,"updateDelay");h(this,"axisDeadZone");h(this,"buttonConfigs");h(this,"currentStateOfGamepads");h(this,"gamepadConnectListeners");h(this,"gamepadDisconnectListeners");h(this,"gamepadButtonChangeListeners");h(this,"gamepadAxisChangeListeners");this.updateDelay=e.updateDelay||0,this.axisDeadZone=e.axisDeadZone||0,this.buttonConfigs=e.buttonConfigs||[],this.currentStateOfGamepads=[],this.gamepadConnectListeners=[],this.gamepadDisconnectListeners=[],this.gamepadButtonChangeListeners=[],this.gamepadAxisChangeListeners=[],navigator.gamepadInputEmulation="gamepad",window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,navigator.getGamepads=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads,this.gamepadApiSupported()&&this.tickLoop()}setButtonsConfig(e){this.buttonConfigs=e}setUpdateDelay(e){this.updateDelay=e}onGamepadConnect(e){return this.gamepadConnectListeners.push(e),window.addEventListener("gamepadconnected",e,!0),e}offGamepadConnect(e){this.gamepadConnectListeners=this.gamepadConnectListeners.filter(t=>t!==e),window.removeEventListener("gamepadconnected",e,!0)}onGamepadDisconnect(e){return this.gamepadDisconnectListeners.push(e),window.addEventListener("gamepaddisconnected",e,!0),e}offGamepadDisconnect(e){this.gamepadDisconnectListeners=this.gamepadDisconnectListeners.filter(t=>t!==e),window.removeEventListener("gamepaddisconnected",e,!0)}onGamepadAxisChange(e){return this.gamepadAxisChangeListeners.push(e),e}offGamepadAxisChange(e){this.gamepadAxisChangeListeners=this.gamepadAxisChangeListeners.filter(t=>t!==e)}onGamepadButtonChange(e){return this.gamepadButtonChangeListeners.push(e),e}offGamepadButtonChange(e){this.gamepadButtonChangeListeners=this.gamepadButtonChangeListeners.filter(t=>t!==e)}gamepadApiSupported(){const e=navigator.getNativeGamepads||navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads;if(e!=null&&typeof e=="function"){const t=e.apply(navigator);return t!=null&&t.length>0}else return!1}getGamepads(){const e=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads;return e&&typeof e=="function"?e.apply(navigator)||[]:[]}getCurrentGamepadStates(e=!1){return e&&this.checkForGamepadChanges(),this.currentStateOfGamepads}cleanup(){this.updateDelay=-1,this.gamepadConnectListeners.forEach(e=>window.removeEventListener("gamepadconnected",e,!0)),this.gamepadDisconnectListeners.forEach(e=>window.removeEventListener("gamepaddisconnected",e,!0)),this.gamepadConnectListeners=[],this.gamepadDisconnectListeners=[],this.gamepadButtonChangeListeners=[],this.gamepadAxisChangeListeners=[]}tickLoop(){this.updateDelay<0||(this.checkForGamepadChanges(),this.updateDelay==0?requestAnimationFrame(this.tickLoop.bind(this)):setTimeout(()=>{requestAnimationFrame(this.tickLoop.bind(this))},this.updateDelay))}checkForGamepadChanges(){let e=this.getGamepads();for(var t=0;t<e.length;t++){let n=e[t];n&&(this.currentStateOfGamepads[t]||(this.currentStateOfGamepads[t]=n),this.checkForAxisChanges(t,n),this.checkForButtonChanges(t,n),this.currentStateOfGamepads[t]=n)}}checkForAxisChanges(e,t){let n=t.axes;if(n.length==0)return;let s=this.currentStateOfGamepads[e].axes||[],r=[],a,o=!1;for(a=0;a<n.length;a++){let p=n[a]||0,m=s[a]||0;if(p!=m){if(Math.abs(p)<this.axisDeadZone&&Math.abs(m)<this.axisDeadZone)continue;r[a]=!0,o=!0}else r[a]=!1}o&&this.gamepadAxisChangeListeners.forEach(p=>p(e,t,r))}checkForButtonChanges(e,t){let n=t.buttons;if(n.length==0)return;const s=this.currentStateOfGamepads[e].buttons||n,r=[];let a,o=!1;for(a=0;a<n.length;a++){let p=!1;const m=n[a]||{pressed:!1,value:0,touched:!1},c=s[a]||{pressed:!1,value:0,touched:!1},l=this.buttonConfigs[a]||{},u={};m.touched&&!c.touched?(u.touchDown=!0,p=!0):!m.touched&&c.touched&&(u.touchUp=!0,p=!0),m.pressed&&!c.pressed?(u.pressed=!0,p=!0):!m.pressed&&c.pressed&&(u.released=!0,p=!0),l.fireWhileHolding&&m.pressed&&c.pressed&&(u.heldDown=!0,p=!0),m.value!=c.value&&(u.valueChanged=!0,p=!0),p?(o=!0,r[a]=u):r[a]=!1}o&&this.gamepadButtonChangeListeners.forEach(p=>p(e,t,r))}}export{R as C,k as D,A as G,j as a,b,g as c,F as d,G as g};
