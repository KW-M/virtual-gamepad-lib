var O=Object.defineProperty,T=Object.defineProperties;var B=Object.getOwnPropertyDescriptors;var A=Object.getOwnPropertySymbols;var k=Object.prototype.hasOwnProperty,F=Object.prototype.propertyIsEnumerable;var E=(o,e,t)=>e in o?O(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,C=(o,e)=>{for(var t in e||(e={}))k.call(e,t)&&E(o,t,e[t]);if(A)for(var t of A(e))F.call(e,t)&&E(o,t,e[t]);return o},D=(o,e)=>T(o,B(e));var h=(o,e,t)=>E(o,typeof e!="symbol"?e+"":e,t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))r(a);new MutationObserver(a=>{for(const s of a)if(s.type==="childList")for(const d of s.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&r(d)}).observe(document,{childList:!0,subtree:!0});function t(a){const s={};return a.integrity&&(s.integrity=a.integrity),a.referrerPolicy&&(s.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?s.credentials="include":a.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(a){if(a.ep)return;a.ep=!0;const s=t(a);fetch(a.href,s)}})();var G=(o=>(o.up="up",o.down="down",o.left="left",o.right="right",o))(G||{}),P=(o=>(o.onOff="onOff",o.variable="variable",o))(P||{}),w=(o=>(o.real="real",o.emulated="emulated",o.overlay="overlay",o))(w||{});function j(o,e,t){const r=Math.sqrt(o*o+e*e);return r>t?{x:o/r,y:e/r}:{x:o/t,y:e/t}}function H(o){if(o instanceof SVGGraphicsElement){o.getAttribute("transform")&&console.warn("VirtualGamepadLib: Setting Transform origin on an element that already has a transform attribute. This may break the transform!",o);const e=o.getBBox();o.style.transformOrigin=`${e.x+e.width/2}px ${e.y+e.height/2}px`}else if(o instanceof HTMLElement){console.warn("VirtualGamepadLib: Setting Transform origin on an element that is not an SVG element. This may break the transform!",o);const e=o.getBoundingClientRect();o.style.transformOrigin=`${e.width/2}px ${e.height/2}px`}}const N=18,S=4,L=class L{constructor(e){h(this,"getNativeGamepads");h(this,"buttonPressThreshold",.1);h(this,"realGpadToPatchedIndexMap",[]);h(this,"patchedGpadToRealIndexMap",[]);h(this,"emulatedGamepads",[]);h(this,"emulatedGamepadsMetadata",[]);h(this,"undoEventPatch",()=>{});if(this.buttonPressThreshold=e||this.buttonPressThreshold,L.instanceRunning)throw new Error("Only one GamepadEmulator instance may exist at a time!");L.instanceRunning=!0,this.undoEventPatch=this.monkeyPatchGamepadEvents(),this.monkeyPatchGetGamepads()}gamepadApiNativelySupported(){return!!this.getNativeGamepads&&!!this.getNativeGamepads.apply(navigator)}AddEmulatedGamepad(e,t,r=N,a=S){if((e===-1||!e&&e!==0)&&(e=this.nextEmptyEGpadIndex(t)),this.emulatedGamepads[e])return!1;const s={emulation:w.emulated,connected:!0,timestamp:performance.now(),displayId:"Emulated Gamepad "+e,id:"Emulated Gamepad "+e+" (Xinput STANDARD GAMEPAD)",mapping:"standard",index:e,buttons:new Array(r).fill({pressed:!1,value:0,touched:!1},0,r),axes:new Array(a).fill(0,0,a),hapticActuators:[]};this.emulatedGamepads[e]=s,this.emulatedGamepadsMetadata[e]={overlayMode:t};const d=new Event("gamepadconnected");return d.gamepad=s,window.dispatchEvent(d),s}RemoveEmulatedGamepad(e){this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);var t=this.emulatedGamepads[e];if(t){delete this.emulatedGamepads[e],delete this.emulatedGamepadsMetadata[e];const r=D(C({},t),{connected:!1,timestamp:performance.now()}),a=new Event("gamepaddisconnected");a.gamepad=r,window.dispatchEvent(a)}else console.warn("GamepadEmulator Error: Cannot remove emulated gamepad. No emulated gamepad exists at index "+e)}PressButton(e,t,r,a){var n;if(this.emulatedGamepads[e]==null)throw new Error("Error: PressButton() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");var s=r>this.buttonPressThreshold;const d=[...((n=this.emulatedGamepads[e])==null?void 0:n.buttons)||[]];d[t]={pressed:s,value:r||0,touched:s||a||!1},Object.defineProperty(this.emulatedGamepads[e],"buttons",{value:d,enumerable:!0,configurable:!0})}MoveAxis(e,t,r){var s;if(this.emulatedGamepads[e]==null)throw new Error("Error: MoveAxis() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");const a=[...((s=this.emulatedGamepads[e])==null?void 0:s.axes)||[]];a[t]=r,Object.defineProperty(this.emulatedGamepads[e],"axes",{value:a,enumerable:!0,configurable:!0})}AddDisplayButtonEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let r=[];for(var a=0;a<t.length;a++){const s=t[a],d=s.buttonIndex,n=s.tapTarget;if(!n){console.warn("GamepadEmulator: No tap target in gamepad "+e+" display config for button "+d+", skipping...");continue}const i=l=>{l.changedTouches[0].target==n&&l.preventDefault()};window.addEventListener("touchstart",i,{passive:!1});const p=l=>{const m=l.buttons==1?1:0;(!s.lockTargetWhilePressed||m==0)&&this.PressButton(e,d,m,!0)};n.addEventListener("pointerenter",p);const u=l=>{const m=l.buttons==1?1:0;(!s.lockTargetWhilePressed||m==0)&&this.PressButton(e,d,0,!1)};n.addEventListener("pointerleave",u);const c=l=>{};if(n.addEventListener("pointercancel",c),s.type==P.onOff){const l=g=>{g.preventDefault(),this.PressButton(e,d,1,!0),s.lockTargetWhilePressed?n.setPointerCapture(g.pointerId):n.releasePointerCapture(g.pointerId)};n.addEventListener("pointerdown",l);const m=()=>{this.PressButton(e,d,0,!0)};n.addEventListener("pointerup",m),r.push(function(){window.removeEventListener("touchstart",i),n.removeEventListener("pointerenter",p),n.removeEventListener("pointerleave",u),n.removeEventListener("pointerdown",l),n.removeEventListener("pointerup",m),n.removeEventListener("pointercancel",c)})}else if(s.type==P.variable){const l=this.AddDragControlListener(s,(m,g,x)=>{let v=m?this.buttonPressThreshold+1e-5:0;v+=s.directions[G.left]||s.directions[G.right]?Math.abs(g):0,v+=s.directions[G.up]||s.directions[G.down]?Math.abs(x):0,this.PressButton(e,d,Math.min(v,1),m)});r.push(function(){window.removeEventListener("touchstart",i),n.removeEventListener("pointerenter",p),n.removeEventListener("pointerleave",u),n.removeEventListener("pointercancel",c),l()})}}this.emulatedGamepadsMetadata[e].removeButtonListenersFunc=()=>{r.forEach(s=>s())}}AddDisplayJoystickEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let r=[];for(let a=0;a<t.length;a++){const s=t[a];if(s.tapTarget==null){console.warn("GamepadEmulator: No tap target in gamepad "+e+" display config for joystick "+a+", skipping...");continue}const d=this.AddDragControlListener(s,(n,i,p)=>{s.xAxisIndex!==void 0&&this.MoveAxis(e,s.xAxisIndex,i),s.yAxisIndex!==void 0&&this.MoveAxis(e,s.yAxisIndex,p)});r.push(d)}this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc=()=>{r.forEach(a=>a())}}ClearDisplayButtonEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])!=null&&t.removeButtonListenersFunc)&&this.emulatedGamepadsMetadata[e].removeButtonListenersFunc()}ClearDisplayJoystickEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])!=null&&t.removeJoystickListenersFunc)&&this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc()}AddDragControlListener(e,t){let r={startX:0,startY:0},a=-1;const s=i=>{var p=i.pointerId;if(a===p){const u=e.directions[G.left]?-1:0,c=e.directions[G.right]?1:0,l=e.directions[G.up]?-1:0,m=e.directions[G.down]?1:0,g=i.clientX-r.startX,x=i.clientY-r.startY;let{x:v,y:f}=j(g,x,e.dragDistance);v=Math.max(Math.min(v,c),u),f=Math.max(Math.min(f,m),l),t(!0,v,f)}},d=i=>{a==i.pointerId&&(document.removeEventListener("pointermove",s,!1),document.removeEventListener("pointerup",d,!1),a=-1,t(!1,0,0))};e.tapTarget.addEventListener("pointerdown",i=>{i.preventDefault(),r.startX=i.clientX,r.startY=i.clientY,a=i.pointerId,e.lockTargetWhilePressed?e.tapTarget.setPointerCapture(i.pointerId):e.tapTarget.releasePointerCapture(i.pointerId),t(!0,0,0),document.addEventListener("pointermove",s,!1),document.addEventListener("pointerup",d,!1)});const n=i=>{i.changedTouches[0].target==e.tapTarget&&i.preventDefault()};return window.addEventListener("touchstart",n,{passive:!1}),function(){window.removeEventListener("touchstart",n),e.tapTarget.removeEventListener("pointerdown",s)}}cloneGamepad(e){if(!e)return e;const t=e.axes?e.axes.length:0,r=e.buttons?e.buttons.length:0,a={};for(let s in e)if(s==="axes"){const d=new Array(t);for(let n=0;n<t;n++)d[n]=Number(e.axes[n]);Object.defineProperty(a,"axes",{value:d,enumerable:!0,configurable:!0})}else if(s==="buttons"){const d=new Array(r);for(let n=0;n<r;n++){const i=e.buttons[n];if(i==null)d[n]=i;else{const p=i.pressed,u=i.value,c=i.touched||!1;d[n]={pressed:p,value:u,touched:c}}}Object.defineProperty(a,"buttons",{value:d,enumerable:!0,configurable:!0})}else Object.defineProperty(a,s,{get:()=>e[s],configurable:!0,enumerable:!0});return a.emulation||Object.defineProperty(a,"emulation",{value:w.real,configurable:!0,enumerable:!0}),a}nextEmptyEGpadIndex(e){let t=0;if(e)do{if(!this.emulatedGamepads[t])break;t++}while(t<this.emulatedGamepads.length);else{const r=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{if(!this.emulatedGamepads[t]&&this.patchedGpadToRealIndexMap[t]==null)break;t++}while(t<r)}return t}nextEmptyRealGpadIndex(e){let t=e;const r=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{const a=this.emulatedGamepadsMetadata[t],s=this.realGpadToPatchedIndexMap[t]==null&&this.patchedGpadToRealIndexMap[t]==null;if(a&&a.overlayMode||!a&&s)break;t++}while(t<r);return t}monkeyPatchGamepadEvents(){let e,t,r,a;window.hasOwnProperty("ongamepadconnected")&&(e=Object.getOwnPropertyDescriptor(window,"ongamepadconnected"),e.configurable=!0,r=window.ongamepadconnected,window.ongamepadconnected=null,Object.defineProperty(window,"ongamepadconnected",{get:()=>function(n){},set:n=>{r=n},configurable:!0})),window.hasOwnProperty("ongamepaddisconnected")&&(t=Object.getOwnPropertyDescriptor(window,"ongamepaddisconnected"),t.configurable=!0,a=window.ongamepaddisconnected,window.ongamepaddisconnected=null,Object.defineProperty(window,"ongamepaddisconnected",{get:()=>function(n){},set:n=>{r=n},configurable:!0}));const s=n=>{const i=n.gamepad;if(i&&i.emulation===void 0){n.stopImmediatePropagation(),n.preventDefault();const p=this.cloneGamepad(n.gamepad),u=p.index,c=this.nextEmptyRealGpadIndex(u);this.realGpadToPatchedIndexMap[u]=c,this.patchedGpadToRealIndexMap[c]=u,Object.defineProperty(p,"index",{get:()=>c}),Object.defineProperty(p,"emulation",{get:()=>w.real});const l=new Event(n.type||"gamepadconnected");l.gamepad=p,window.dispatchEvent(l)}r&&r.call(window,n)};window.addEventListener("gamepadconnected",s);const d=n=>{const i=n.gamepad;if(i&&i.emulation===void 0){n.stopImmediatePropagation(),n.preventDefault();const p=this.cloneGamepad(n.gamepad),u=this.realGpadToPatchedIndexMap[p.index]||p.index;Object.defineProperty(p,"index",{get:()=>u}),Object.defineProperty(p,"emulation",{get:()=>w.real}),delete this.realGpadToPatchedIndexMap[p.index],delete this.patchedGpadToRealIndexMap[u];const c=new Event(n.type||"gamepaddisconnected");c.gamepad=p,window.dispatchEvent(c)}a&&a.call(window,n)};return window.addEventListener("gamepaddisconnected",d),function(){window.removeEventListener("gamepadconnected",s),window.hasOwnProperty("ongamepadconnected")&&(Object.defineProperty(window,"ongamepadconnected",e),window.ongamepadconnected=r),window.removeEventListener("gamepaddisconnected",d),window.hasOwnProperty("ongamepaddisconnected")&&(Object.defineProperty(window,"ongamepaddisconnected",t),window.ongamepaddisconnected=a)}}monkeyPatchGetGamepads(){const e=this;let t=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads;this.getNativeGamepads=t,navigator.getNativeGamepads=t||function(){return[]},Object.defineProperty(navigator,"getGamepads",{configurable:!0,value:function(){var d,n,i,p;let r=e.emulatedGamepads,a=t!=null?t.apply(navigator)||[]:[],s=new Array(Math.max(a.length,r.length)).fill(null);for(let u=0;u<a.length;u++){const c=a[u];if(!c)continue;let l=e.cloneGamepad(c),m=e.realGpadToPatchedIndexMap[l.index]||l.index;Object.defineProperty(l,"index",{get:()=>m}),s[m]=l}for(let u=0;u<r.length;u++){let c=s[u],l=r[u];if(l&&c){Object.defineProperty(s[u],"emulation",{value:w.overlay,configurable:!0});let m=Math.max((n=(d=c==null?void 0:c.buttons)==null?void 0:d.length)!=null?n:0,l.buttons.length),g=new Array(m);for(let f=0;f<m;f++){const b=(l==null?void 0:l.buttons[f])||{touched:!1,pressed:!1,value:0},y=(c==null?void 0:c.buttons[f])||{touched:!1,pressed:!1,value:0};g[f]={touched:b.touched||y.touched||!1,pressed:b.pressed||y.pressed||!1,value:Math.max(b.value,y.value)||0}}Object.defineProperty(s[u],"buttons",{value:g,enumerable:!0,configurable:!0});let x=Math.max(l.axes.length,c.axes.length),v=new Array(m);for(let f=0;f<x;f++){const b=(i=l.axes[f])!=null?i:0,y=(p=c.axes[f])!=null?p:0;v[f]=Math.abs(b)>Math.abs(y)?b:y}Object.defineProperty(s[u],"axes",{value:v,enumerable:!0,configurable:!0})}else l&&(Object.defineProperty(l,"emulation",{value:w.emulated,enumerable:!0,configurable:!0}),Object.defineProperty(l,"timestamp",{value:performance.now(),enumerable:!0,configurable:!0}),s[u]=e.cloneGamepad(l))}return s}})}cleanup(){for(let e=0;e<this.emulatedGamepads.length;e++)this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);this.emulatedGamepads=[],this.undoEventPatch(),this.getNativeGamepads?Object.defineProperty(navigator,"getGamepads",{value:this.getNativeGamepads,configurable:!0}):Object.defineProperty(navigator,"getGamepads",{value:void 0,configurable:!0}),L.instanceRunning=!1,delete navigator.getNativeGamepads}};h(L,"instanceRunning",!1);let M=L;class q{constructor(e){h(this,"updateDelay");h(this,"axisDeadZone");h(this,"buttonConfigs");h(this,"currentStateOfGamepads");h(this,"gamepadConnectListeners");h(this,"gamepadDisconnectListeners");h(this,"gamepadButtonChangeListeners");h(this,"gamepadAxisChangeListeners");h(this,"_requestAnimationFrame");h(this,"_getGamepads");this.updateDelay=e.updateDelay||0,this.axisDeadZone=e.axisDeadZone||0,this.buttonConfigs=e.buttonConfigs||[],this.currentStateOfGamepads=[],this.gamepadConnectListeners=[],this.gamepadDisconnectListeners=[],this.gamepadButtonChangeListeners=[],this.gamepadAxisChangeListeners=[],navigator.gamepadInputEmulation="gamepad",this._requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,this._getGamepads=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads,(this.gamepadApiSupported()||navigator.getNativeGamepads!==void 0)&&this.tickLoop()}setButtonsConfig(e){this.buttonConfigs=e}setUpdateDelay(e){this.updateDelay=e}onGamepadConnect(e){return this.gamepadConnectListeners.push(e),window.addEventListener("gamepadconnected",e,!0),e}offGamepadConnect(e){this.gamepadConnectListeners=this.gamepadConnectListeners.filter(t=>t!==e),window.removeEventListener("gamepadconnected",e,!0)}onGamepadDisconnect(e){return this.gamepadDisconnectListeners.push(e),window.addEventListener("gamepaddisconnected",e,!0),e}offGamepadDisconnect(e){this.gamepadDisconnectListeners=this.gamepadDisconnectListeners.filter(t=>t!==e),window.removeEventListener("gamepaddisconnected",e,!0)}onGamepadAxisChange(e){return this.gamepadAxisChangeListeners.push(e),e}offGamepadAxisChange(e){this.gamepadAxisChangeListeners=this.gamepadAxisChangeListeners.filter(t=>t!==e)}onGamepadButtonChange(e){return this.gamepadButtonChangeListeners.push(e),e}offGamepadButtonChange(e){this.gamepadButtonChangeListeners=this.gamepadButtonChangeListeners.filter(t=>t!==e)}gamepadApiSupported(){const e=navigator.getNativeGamepads||navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads;if(e!=null&&typeof e=="function"){const t=e.apply(navigator);return t!=null&&t.length>0}else return!1}getGamepads(){const e=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads;return e&&typeof e=="function"?e.apply(navigator)||[]:[]}getCurrentGamepadStates(e=!1){return e&&this.checkForGamepadChanges(),this.currentStateOfGamepads}cleanup(){this.updateDelay=-1,this.gamepadConnectListeners.forEach(e=>window.removeEventListener("gamepadconnected",e,!0)),this.gamepadDisconnectListeners.forEach(e=>window.removeEventListener("gamepaddisconnected",e,!0)),this.gamepadConnectListeners=[],this.gamepadDisconnectListeners=[],this.gamepadButtonChangeListeners=[],this.gamepadAxisChangeListeners=[]}tickLoop(){this.updateDelay<0||(this.checkForGamepadChanges(),this.updateDelay==0?requestAnimationFrame(this.tickLoop.bind(this)):setTimeout(()=>{requestAnimationFrame(this.tickLoop.bind(this))},this.updateDelay))}checkForGamepadChanges(){let e=this.getGamepads();for(var t=0;t<e.length;t++){let r=e[t];r&&(this.checkForAxisChanges(t,r),this.checkForButtonChanges(t,r),this.currentStateOfGamepads[t]=r)}}checkForAxisChanges(e,t){let r=t.axes;if(r.length==0)return;const a=this.currentStateOfGamepads[e];let s=(a==null?void 0:a.axes)||[],d=[],n,i=!1;for(n=0;n<r.length;n++){let p=r[n]||0,u=s[n]||0;if(p!=u){if(Math.abs(p)<this.axisDeadZone&&Math.abs(u)<this.axisDeadZone)continue;d[n]=!0,i=!0}else d[n]=!1}i&&this.gamepadAxisChangeListeners.forEach(p=>p(e,t,d))}checkForButtonChanges(e,t){let r=t.buttons;if(r.length==0)return;const a=this.currentStateOfGamepads[e],s=(a==null?void 0:a.buttons)||r,d=new Array(r.length).fill(!1);let n=!1;for(let i=0;i<r.length;i++){let p=!1;const u=r[i]||{pressed:!1,value:0,touched:!1},c=s[i]||{pressed:!1,value:0,touched:!1},l=this.buttonConfigs[i]||{},m={};u.touched&&!c.touched?(m.touchDown=!0,p=!0):!u.touched&&c.touched&&(m.touchUp=!0,p=!0),u.pressed&&!c.pressed?(m.pressed=!0,p=!0):!u.pressed&&c.pressed&&(m.released=!0,p=!0),l.fireWhileHolding&&u.pressed&&c.pressed&&(m.heldDown=!0,p=!0),u.value!=c.value&&(m.valueChanged=!0,p=!0),p?(n=!0,d[i]=m):d[i]=!1}n&&this.gamepadButtonChangeListeners.forEach(i=>i(e,t,d))}}export{H as C,N as D,M as G,q as a,P as b,G as c,S as d,w as g};
