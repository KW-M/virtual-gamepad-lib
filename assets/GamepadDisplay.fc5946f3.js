var S=Object.defineProperty,j=Object.defineProperties;var N=Object.getOwnPropertyDescriptors;var B=Object.getOwnPropertySymbols;var _=Object.prototype.hasOwnProperty,J=Object.prototype.propertyIsEnumerable;var M=(l,e,t)=>e in l?S(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,O=(l,e)=>{for(var t in e||(e={}))_.call(e,t)&&M(l,t,e[t]);if(B)for(var t of B(e))J.call(e,t)&&M(l,t,e[t]);return l},F=(l,e)=>j(l,N(e));var m=(l,e,t)=>(M(l,typeof e!="symbol"?e+"":e,t),t),T=(l,e,t)=>{if(!e.has(l))throw TypeError("Cannot "+t)};var C=(l,e,t)=>(T(l,e,"read from private field"),t?t.call(l):e.get(l)),x=(l,e,t)=>{if(e.has(l))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(l):e.set(l,t)},k=(l,e,t,n)=>(T(l,e,"write to private field"),n?n.call(l,t):e.set(l,t),t);var I=(l,e,t)=>(T(l,e,"access private method"),t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))n(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const d of s.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&n(d)}).observe(document,{childList:!0,subtree:!0});function t(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerpolicy&&(s.referrerPolicy=o.referrerpolicy),o.crossorigin==="use-credentials"?s.credentials="include":o.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(o){if(o.ep)return;o.ep=!0;const s=t(o);fetch(o.href,s)}})();var f;(function(l){l.up="up",l.down="down",l.left="left",l.right="right"})(f||(f={}));var L;(function(l){l.onOff="onOff",l.variable="variable"})(L||(L={}));var G;(function(l){l.real="real",l.emulated="emulated",l.overlay="overlay"})(G||(G={}));function W(l,e,t){const n=Math.sqrt(l*l+e*e);return n>t?{x:l/n,y:e/n}:{x:l/t,y:e/t}}const X=18,q=4,y=class{constructor(e){m(this,"getNativeGamepads",()=>[]);m(this,"buttonPressThreshold",.1);m(this,"realGamepadCount",0);m(this,"realGpadToPatchedIndexMap",[]);m(this,"patchedGpadToRealIndexMap",[]);m(this,"emulatedGamepads",[]);m(this,"emulatedGamepadsMetadata",[]);m(this,"undoEventPatch",()=>{});if(this.buttonPressThreshold=e||this.buttonPressThreshold,y.instanceRunning)throw new Error("Only one GamepadEmulator instance may exist at a time!");y.instanceRunning=!0,this.undoEventPatch=this.monkeyPatchGamepadEvents(),this.monkeyPatchGetGamepads()}AddEmulatedGamepad(e,t,n=X,o=q){if((e===-1||!e&&e!==0)&&(e=this.nextEmptyEGpadIndex(t)),this.emulatedGamepads[e])return!1;const s={emulation:G.emulated,connected:!0,timestamp:Math.floor(Date.now()/1e3),displayId:"Emulated Gamepad "+e,id:"Emulated Gamepad "+e+" (Xinput STANDARD GAMEPAD)",mapping:"standard",index:e,buttons:new Array(n).fill({pressed:!1,value:0,touched:!1},0,n),axes:new Array(o).fill(0,0,o),hapticActuators:[]};this.emulatedGamepads[e]=s,this.emulatedGamepadsMetadata[e]={overlayMode:t};const d=new Event("gamepadconnected");return d.gamepad=s,window.dispatchEvent(d),s}RemoveEmulatedGamepad(e){this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);var t=this.emulatedGamepads[e];if(t){delete this.emulatedGamepads[e],delete this.emulatedGamepadsMetadata[e];const n=F(O({},t),{connected:!1,timestamp:Math.floor(Date.now()/1e3)}),o=new Event("gamepaddisconnected");o.gamepad=n,window.dispatchEvent(o)}else console.warn("Error: removing emulated gamepad. No emulated gamepad exists at index "+e)}PressButton(e,t,n,o){if(this.emulatedGamepads[e]===void 0)throw new Error("Error: PressButton() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");var s=n>this.buttonPressThreshold;this.emulatedGamepads[e].buttons[t]={pressed:s,value:n||0,touched:s||o||!1}}MoveAxis(e,t,n){if(!this.emulatedGamepads[e])throw new Error("Error: MoveAxis() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");this.emulatedGamepads[e].axes[t]=n}AddDisplayButtonEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let n=[];for(var o=0;o<t.length;o++){const s=t[o],d=s.buttonIndex,a=s.tapTarget;if(!a){console.warn("AddDisplayButtonEventListeners() - no tap target for button index "+d+", skipping");continue}const i=h=>{h.changedTouches[0].target==a&&h.preventDefault()};window.addEventListener("touchstart",i,{passive:!1});const r=h=>{const u=h.buttons==1?1:0;(!s.lockTargetWhilePressed||u==0)&&this.PressButton(e,d,u,!0)};a.addEventListener("pointerenter",r);const p=h=>{const u=h.buttons==1?1:0;(!s.lockTargetWhilePressed||u==0)&&this.PressButton(e,d,0,!1)};a.addEventListener("pointerleave",p);const c=h=>{};if(a.addEventListener("pointercancel",c),s.type==L.onOff){const h=g=>{g.preventDefault(),this.PressButton(e,d,1,!0),s.lockTargetWhilePressed?a.setPointerCapture(g.pointerId):a.releasePointerCapture(g.pointerId),console.log("on/off pointer down",a.hasPointerCapture(g.pointerId))};a.addEventListener("pointerdown",h);const u=()=>{this.PressButton(e,d,0,!0)};a.addEventListener("pointerup",u),n.push(function(){window.removeEventListener("touchstart",i),a.removeEventListener("pointerenter",r),a.removeEventListener("pointerleave",p),a.removeEventListener("pointerdown",h),a.removeEventListener("pointerup",u),a.removeEventListener("pointercancel",c)})}else if(s.type==L.variable){const h=O({},s),u=this.AddDragControlListener(h,(g,P,w)=>{let v=g?this.buttonPressThreshold+1e-5:0;v+=s.directions[f.left]||s.directions[f.right]?Math.abs(P):0,v+=s.directions[f.up]||s.directions[f.down]?Math.abs(w):0,this.PressButton(e,s.buttonIndex,Math.min(v,1),g)});n.push(function(){window.removeEventListener("touchstart",i),a.removeEventListener("pointerenter",r),a.removeEventListener("pointerleave",p),a.removeEventListener("pointercancel",c),u()})}}this.emulatedGamepadsMetadata[e].removeButtonListenersFunc=()=>{n.forEach(s=>s())}}AddDisplayJoystickEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let n=[];for(let o=0;o<t.length;o++){const s=t[o],d=this.AddDragControlListener(s,(a,i,r)=>{s.xAxisIndex!==void 0&&this.MoveAxis(e,s.xAxisIndex,i),s.yAxisIndex!==void 0&&this.MoveAxis(e,s.yAxisIndex,r)});n.push(d)}this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc=()=>{n.forEach(o=>o())}}ClearDisplayButtonEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])==null?void 0:t.removeButtonListenersFunc)&&this.emulatedGamepadsMetadata[e].removeButtonListenersFunc()}ClearDisplayJoystickEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])==null?void 0:t.removeJoystickListenersFunc)&&this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc()}AddDragControlListener(e,t){let n={startX:0,startY:0},o=-1;const s=i=>{var r=i.pointerId;if(o===r){const p=e.directions[f.left]?-1:0,c=e.directions[f.right]?1:0,h=e.directions[f.up]?-1:0,u=e.directions[f.down]?1:0,g=i.clientX-n.startX,P=i.clientY-n.startY;let{x:w,y:v}=W(g,P,e.dragDistance);w=Math.max(Math.min(w,c),p),v=Math.max(Math.min(v,u),h),t(!0,w,v)}},d=i=>{o==i.pointerId&&(document.removeEventListener("pointermove",s,!1),document.removeEventListener("pointerup",d,!1),o=-1,t(!1,0,0))};e.tapTarget.addEventListener("pointerdown",i=>{i.preventDefault(),n.startX=i.clientX,n.startY=i.clientY,o=i.pointerId,e.lockTargetWhilePressed?e.tapTarget.setPointerCapture(i.pointerId):e.tapTarget.releasePointerCapture(i.pointerId),console.log("stick pointer down",e.tapTarget.hasPointerCapture(i.pointerId)),t(!0,0,0),document.addEventListener("pointermove",s,!1),document.addEventListener("pointerup",d,!1)});const a=i=>{i.changedTouches[0].target==e.tapTarget&&i.preventDefault()};return window.addEventListener("touchstart",a,{passive:!1}),function(){window.removeEventListener("touchstart",a),e.tapTarget.removeEventListener("pointerdown",s)}}cloneGamepad(e){if(!e)return e;const t=e.axes?e.axes.length:0,n=e.buttons?e.buttons.length:0,o={};for(let s in e)if(s==="axes"){const d=new Array(t);for(let a=0;a<t;a++)d[a]=Number(e.axes[a]);Object.defineProperty(o,"axes",{value:d,enumerable:!0})}else if(s==="buttons"){const d=new Array(n);for(let a=0;a<n;a++){const i=e.buttons[a];if(i==null)d[a]=i;else{const r=i.pressed,p=i.value,c=i.touched||!1;d[a]={pressed:r,value:p,touched:c}}}Object.defineProperty(o,"buttons",{value:d,enumerable:!0})}else Object.defineProperty(o,s,{get:()=>e[s],configurable:!0,enumerable:!0});return o.emulation||(o.emulation=G.real),o}nextEmptyEGpadIndex(e){let t=0;if(e)do{if(!this.emulatedGamepads[t])break;t++}while(t<this.emulatedGamepads.length);else{const n=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{if(!this.emulatedGamepads[t]&&this.patchedGpadToRealIndexMap[t]==null)break;console.log("nextEmptyEGpadIndex",t,!this.emulatedGamepads[t],this.patchedGpadToRealIndexMap[t]==null),t++}while(t<n)}return t}nextEmptyRealGpadIndex(e){let t=e;const n=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{const o=this.emulatedGamepadsMetadata[t],s=this.realGpadToPatchedIndexMap[t]==null&&this.patchedGpadToRealIndexMap[t]==null;if(!!o&&o.overlayMode||!o&&s)break;t++}while(t<n);return t}monkeyPatchGamepadEvents(){let e,t,n,o;window.hasOwnProperty("ongamepadconnected")&&(e=Object.getOwnPropertyDescriptor(window,"ongamepadconnected"),n=e.get(),window.ongamepadconnected=null,Object.defineProperty(window,"ongamepadconnected",{get:()=>function(a){},set:a=>{n=a},configurable:!0})),window.hasOwnProperty("ongamepaddisconnected")&&(t=Object.getOwnPropertyDescriptor(window,"ongamepaddisconnected"),o=t.get(),window.ongamepaddisconnected=null,Object.defineProperty(window,"ongamepaddisconnected",{get:()=>function(a){},set:a=>{n=a},configurable:!0}));const s=a=>{const i=a.gamepad;if(i&&i.emulation===void 0){a.stopImmediatePropagation();const r=this.cloneGamepad(a.gamepad),p=r.index,c=this.nextEmptyRealGpadIndex(p);this.realGpadToPatchedIndexMap[p]=c,this.patchedGpadToRealIndexMap[c]=p,Object.defineProperty(r,"index",{get:()=>c}),Object.defineProperty(r,"emulation",{get:()=>G.real}),this.realGamepadCount++,console.log(`real gamepad connected ${r.id} (${p}>${c})`,this.realGpadToPatchedIndexMap,this.emulatedGamepads,this.emulatedGamepadsMetadata);const h=new Event("gamepadconnected");h.gamepad=r,window.dispatchEvent(h),console.log("windowOngamepadconnected",n),n&&n.call(window,h)}};window.addEventListener("gamepadconnected",s);const d=a=>{const i=a.gamepad;if(i&&i.emulation===void 0){a.stopImmediatePropagation();const r=this.cloneGamepad(a.gamepad),p=this.realGpadToPatchedIndexMap[r.index]||r.index;Object.defineProperty(r,"index",{get:()=>p}),delete this.realGpadToPatchedIndexMap[r.index],delete this.patchedGpadToRealIndexMap[p],this.realGamepadCount--;const c=new Event("gamepaddisconnected");c.gamepad=r,window.dispatchEvent(c),o&&o.call(window,c)}};return window.addEventListener("gamepaddisconnected",d),function(){window.removeEventListener("gamepadconnected",s),window.hasOwnProperty("ongamepadconnected")&&(Object.defineProperty(window,"ongamepadconnected",e),window.ongamepadconnected=n),window.removeEventListener("gamepaddisconnected",d),window.hasOwnProperty("ongamepaddisconnected")&&(Object.defineProperty(window,"ongamepaddisconnected",t),window.ongamepaddisconnected=o)}}monkeyPatchGetGamepads(){const e=this;let t=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads;t&&(this.getNativeGamepads=t),navigator.getGamepads=function(){let n=[],o=t!=null?e.getNativeGamepads.apply(navigator):[];for(let d=0;d<o.length;d++){const a=o[d];if(!a)continue;let i=e.cloneGamepad(a),r=e.realGpadToPatchedIndexMap[i.index]||i.index;Object.defineProperty(i,"index",{get:()=>r}),n[r]=i}let s=e.emulatedGamepads;for(let d=0;d<s.length;d++){let a=n[d],i=s[d];if(i&&a){a.emulation=G.overlay;let r=Math.max(a.buttons.length,i.buttons.length);for(let c=0;c<r;c++){const h=i.buttons[c]||{touched:!1,pressed:!1,value:0},u=a.buttons[c]||{touched:!1,pressed:!1,value:0};n[d].buttons[c]={touched:h.touched||u.touched||!1,pressed:h.pressed||u.pressed||!1,value:Math.max(h.value,u.value)||0}}let p=Math.max(i.axes.length,a.axes.length);for(let c=0;c<p;c++){const h=i.axes[c]||0,u=a.axes[c]||0;n[d].axes[c]=Math.abs(h||0)>Math.abs(u||0)?h||0:u||0}}else i&&(i.emulation=G.emulated,i.timestamp=Math.floor(Date.now()/1e3),n[d]=e.cloneGamepad(i))}return n}}cleanup(){for(let e=0;e<this.emulatedGamepads.length;e++)this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);this.emulatedGamepads=[],this.undoEventPatch(),navigator.getGamepads=this.getNativeGamepads,y.instanceRunning=!1}};let H=y;m(H,"instanceRunning",!1);class U{constructor(e){m(this,"updateDelay");m(this,"axisDeadZone");m(this,"buttonConfigs");m(this,"lastStateOfGamepads");m(this,"changeMaskOfGamepads");m(this,"gamepadConnectListeners");m(this,"gamepadDisconnectListeners");m(this,"gamepadButtonChangeListeners");m(this,"gamepadAxisChangeListeners");this.updateDelay=e.updateDelay||0,this.axisDeadZone=e.axisDeadZone||0,this.buttonConfigs=e.buttonConfigs||[],this.lastStateOfGamepads=[],this.changeMaskOfGamepads=[],this.gamepadConnectListeners=[],this.gamepadDisconnectListeners=[],this.gamepadButtonChangeListeners=[],this.gamepadAxisChangeListeners=[],navigator.gamepadInputEmulation="gamepad",window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,navigator.getGamepads=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads,this.gamepadApiSupported()&&this.tickLoop()}set buttonsConfig(e){this.buttonConfigs=e}onGamepadConnect(e){this.gamepadConnectListeners.push(e),window.addEventListener("gamepadconnected",e,!0)}offGamepadConnect(e){this.gamepadConnectListeners=this.gamepadConnectListeners.filter(t=>t!==e),window.removeEventListener("gamepadconnected",e,!0)}onGamepadDisconnect(e){this.gamepadDisconnectListeners.push(e),window.addEventListener("gamepaddisconnected",e,!0)}offGamepadDisconnect(e){this.gamepadDisconnectListeners=this.gamepadDisconnectListeners.filter(t=>t!==e),window.removeEventListener("gamepaddisconnected",e,!0)}onGamepadAxisChange(e){return this.gamepadAxisChangeListeners.push(e),e}offGamepadAxisChange(e){this.gamepadAxisChangeListeners=this.gamepadAxisChangeListeners.filter(t=>t!==e)}onGamepadButtonChange(e){return this.gamepadButtonChangeListeners.push(e),e}offGamepadButtonChange(e){this.gamepadButtonChangeListeners=this.gamepadButtonChangeListeners.filter(t=>t!==e)}gamepadApiSupported(){return!!navigator.getGamepads&&!!navigator.getGamepads()}tickLoop(){this.checkForGamepadChanges(),this.updateDelay==0?requestAnimationFrame(this.tickLoop.bind(this)):setTimeout(()=>{requestAnimationFrame(this.tickLoop.bind(this))},this.updateDelay)}checkForGamepadChanges(){let e=navigator.getGamepads();for(var t=0;t<e.length;t++){let n=e[t];!n||(this.lastStateOfGamepads[t]||(this.lastStateOfGamepads[t]=n),this.checkForAxisChanges(t,n),this.checkForButtonChanges(t,n),this.lastStateOfGamepads[t]=n)}}checkForAxisChanges(e,t){let n=t.axes;if(n.length==0)return;let s=this.lastStateOfGamepads[e].axes||[],d=[],a,i=!1;for(a=0;a<n.length;a++){let r=n[a]||0,p=s[a]||0;!(Math.abs(r)<this.axisDeadZone)&&r!=p?(d[a]=!0,i=!0):d[a]=!1}i&&this.gamepadAxisChangeListeners.forEach(r=>r(e,t,d))}checkForButtonChanges(e,t){let n=t.buttons;if(n.length==0)return;const s=this.lastStateOfGamepads[e].buttons||n;let d=[],a,i=!1;for(a=0;a<n.length;a++){let r=!1;const p=n[a]||{pressed:!1,value:0,touched:!1},c=s[a]||{pressed:!1,value:0,touched:!1},h=this.buttonConfigs[a]||{},u={};p.touched&&!c.touched?(u.touchDown=!0,r=!0):!p.touched&&c.touched&&(u.touchUp=!0,r=!0),p.pressed&&!c.pressed?(u.pressed=!0,r=!0):!p.pressed&&c.pressed&&(u.released=!0,r=!0),h.fireWhileHolding&&p.pressed&&c.pressed&&(u.heldDown=!0,r=!0),p.value!=c.value&&(u.valueChanged=!0,r=!0),r?(i=!0,d[a]=u):d[a]=!1}i&&this.gamepadButtonChangeListeners.forEach(r=>r(e,t,d))}}var E,b,D,A,R;class Y{constructor(e,t){x(this,A);m(this,"config");m(this,"apiWrapper");x(this,E,void 0);x(this,b,void 0);m(this,"defaultJoystickDisplayFunction",(e,t,n)=>{const o=e.movementRange;if(e.joystickElement.style.transform=`translate(${t*o}px,${n*o}px)`,e.highlights&&this.config.moveDirectionHighlightClass){const s=e.highlights[f.up],d=e.highlights[f.down],a=e.highlights[f.left],i=e.highlights[f.right];s&&n<-.1?s.classList.add(this.config.moveDirectionHighlightClass||""):s&&s.classList.remove(this.config.moveDirectionHighlightClass||""),d&&n>.1?d.classList.add(this.config.moveDirectionHighlightClass||""):d&&d.classList.remove(this.config.moveDirectionHighlightClass||""),a&&t<-.1?a.classList.add(this.config.moveDirectionHighlightClass||""):a&&a.classList.remove(this.config.moveDirectionHighlightClass||""),i&&t>.1?i.classList.add(this.config.moveDirectionHighlightClass||""):i&&i.classList.remove(this.config.moveDirectionHighlightClass||"")}});m(this,"defaultButtonDisplayFunction",(e,t,n,o,s,d)=>{const a=e.highlight;if(this.config.touchedHighlightClass&&a&&(s.touchDown?a.classList.add(this.config.touchedHighlightClass):s.touchUp&&a.classList.remove(this.config.touchedHighlightClass)),this.config.pressedHighlightClass&&a&&(s.pressed?a.classList.add(this.config.pressedHighlightClass):s.released&&a.classList.remove(this.config.pressedHighlightClass)),e.type==L.variable){const i=e.directionHighlight;if(this.config.moveDirectionHighlightClass&&i&&(s.pressed?i.classList.add(this.config.moveDirectionHighlightClass):s.released&&i.classList.remove(this.config.moveDirectionHighlightClass)),e.buttonElement){const r=e.direction==f.left||e.direction==f.right,p=e.direction==f.right||e.direction==f.down;e.buttonElement.style.transform=`translate${r?"X":"Y"}(${p?"":"-"}${t*e.movementRange}px)`}}});x(this,D,(e,t,n)=>{if(e!=this.config.gamepadIndex)return;const o=this.config.buttons;for(let s=0;s<o.length;s++){const d=n[s];if(!d||Object.keys(d).length==0)continue;const a=o[s],i=t.buttons[s].value,r=t.buttons[s].touched,p=t.buttons[s].pressed;this.config.buttonDisplayFunction?this.config.buttonDisplayFunction(a,i,r,p,d,s):this.defaultButtonDisplayFunction(a,i,r,p,d,s)}});this.config=e,this.apiWrapper=t||new U({buttonConfigs:[],updateDelay:0}),k(this,E,this.apiWrapper.onGamepadButtonChange(C(this,D).bind(this))),k(this,b,this.apiWrapper.onGamepadAxisChange(I(this,A,R).bind(this)))}cleanup(){this.apiWrapper.offGamepadButtonChange(C(this,E)),this.apiWrapper.offGamepadAxisChange(C(this,b))}}E=new WeakMap,b=new WeakMap,D=new WeakMap,A=new WeakSet,R=function(e,t,n){if(e!=this.config.gamepadIndex)return;const o=this.config.sticks;for(let s=0;s<o.length;s++){const d=o[s];if(d.xAxisIndex!==void 0&&n[d.xAxisIndex]||d.yAxisIndex!==void 0&&n[d.yAxisIndex]){const a=t.axes,i=d.xAxisIndex!==void 0&&a[d.xAxisIndex]||0,r=d.yAxisIndex!==void 0&&a[d.yAxisIndex]||0;this.config.joystickDisplayFunction?this.config.joystickDisplayFunction(d,i,r):this.defaultJoystickDisplayFunction(d,i,r)}}};export{X as D,H as G,U as a,L as b,f as c,Y as d,q as e,G as g};
