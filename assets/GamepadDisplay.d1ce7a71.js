var S=Object.defineProperty,j=Object.defineProperties;var N=Object.getOwnPropertyDescriptors;var B=Object.getOwnPropertySymbols;var _=Object.prototype.hasOwnProperty,J=Object.prototype.propertyIsEnumerable;var M=(l,e,t)=>e in l?S(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,O=(l,e)=>{for(var t in e||(e={}))_.call(e,t)&&M(l,t,e[t]);if(B)for(var t of B(e))J.call(e,t)&&M(l,t,e[t]);return l},F=(l,e)=>j(l,N(e));var m=(l,e,t)=>(M(l,typeof e!="symbol"?e+"":e,t),t),T=(l,e,t)=>{if(!e.has(l))throw TypeError("Cannot "+t)};var C=(l,e,t)=>(T(l,e,"read from private field"),t?t.call(l):e.get(l)),x=(l,e,t)=>{if(e.has(l))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(l):e.set(l,t)},k=(l,e,t,s)=>(T(l,e,"write to private field"),s?s.call(l,t):e.set(l,t),t);var I=(l,e,t)=>(T(l,e,"access private method"),t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const n of o)if(n.type==="childList")for(const d of n.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&s(d)}).observe(document,{childList:!0,subtree:!0});function t(o){const n={};return o.integrity&&(n.integrity=o.integrity),o.referrerpolicy&&(n.referrerPolicy=o.referrerpolicy),o.crossorigin==="use-credentials"?n.credentials="include":o.crossorigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(o){if(o.ep)return;o.ep=!0;const n=t(o);fetch(o.href,n)}})();var f;(function(l){l.up="up",l.down="down",l.left="left",l.right="right"})(f||(f={}));var L;(function(l){l.onOff="onOff",l.variable="variable"})(L||(L={}));var G;(function(l){l.real="real",l.emulated="emulated",l.overlay="overlay"})(G||(G={}));function W(l,e,t){const s=Math.sqrt(l*l+e*e);return s>t?{x:l/s,y:e/s}:{x:l/t,y:e/t}}const X=18,q=4,y=class{constructor(e){m(this,"getNativeGamepads",()=>[]);m(this,"buttonPressThreshold",.1);m(this,"realGamepadCount",0);m(this,"realGpadToPatchedIndexMap",[]);m(this,"patchedGpadToRealIndexMap",[]);m(this,"emulatedGamepads",[]);m(this,"emulatedGamepadsMetadata",[]);m(this,"undoEventPatch",()=>{});if(this.buttonPressThreshold=e||this.buttonPressThreshold,y.instanceRunning)throw new Error("Only one GamepadEmulator instance may exist at a time!");y.instanceRunning=!0,this.undoEventPatch=this.monkeyPatchGamepadEvents(),this.monkeyPatchGetGamepads()}AddEmulatedGamepad(e,t,s=X,o=q){if((e===-1||!e&&e!==0)&&(e=this.nextEmptyEGpadIndex(t)),this.emulatedGamepads[e])return!1;const n={emulation:G.emulated,connected:!0,timestamp:Math.floor(Date.now()/1e3),displayId:"Emulated Gamepad "+e,id:"Emulated Gamepad "+e+" (Xinput STANDARD GAMEPAD)",mapping:"standard",index:e,buttons:new Array(s).fill({pressed:!1,value:0,touched:!1},0,s),axes:new Array(o).fill(0,0,o),hapticActuators:[]};this.emulatedGamepads[e]=n,this.emulatedGamepadsMetadata[e]={overlayMode:t};const d=new Event("gamepadconnected");return d.gamepad=n,window.dispatchEvent(d),n}RemoveEmulatedGamepad(e){this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);var t=this.emulatedGamepads[e];if(t){delete this.emulatedGamepads[e],delete this.emulatedGamepadsMetadata[e];const s=F(O({},t),{connected:!1,timestamp:Math.floor(Date.now()/1e3)}),o=new Event("gamepaddisconnected");o.gamepad=s,window.dispatchEvent(o)}else console.warn("Error: removing emulated gamepad. No emulated gamepad exists at index "+e)}PressButton(e,t,s,o){if(this.emulatedGamepads[e]===void 0)throw new Error("Error: PressButton() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");var n=s>this.buttonPressThreshold;this.emulatedGamepads[e].buttons[t]={pressed:n,value:s||0,touched:n||o||!1}}MoveAxis(e,t,s){if(!this.emulatedGamepads[e])throw new Error("Error: MoveAxis() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");this.emulatedGamepads[e].axes[t]=s}AddDisplayButtonEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let s=[];for(var o=0;o<t.length;o++){const n=t[o],d=n.buttonIndex,a=n.tapTarget;if(!a){console.warn("AddDisplayButtonEventListeners() - no tap target for button index "+d+", skipping");continue}const i=h=>{h.changedTouches[0].target==a&&h.preventDefault()};window.addEventListener("touchstart",i,{passive:!1});const r=h=>{const u=h.buttons==1?1:0;(!n.lockTargetWhilePressed||u==0)&&this.PressButton(e,d,u,!0)};a.addEventListener("pointerenter",r);const p=h=>{const u=h.buttons==1?1:0;(!n.lockTargetWhilePressed||u==0)&&this.PressButton(e,d,0,!1)};a.addEventListener("pointerleave",p);const c=h=>{};if(a.addEventListener("pointercancel",c),n.type==L.onOff){const h=g=>{g.preventDefault(),this.PressButton(e,d,1,!0),n.lockTargetWhilePressed?a.setPointerCapture(g.pointerId):a.releasePointerCapture(g.pointerId),console.log("on/off pointer down",a.hasPointerCapture(g.pointerId))};a.addEventListener("pointerdown",h);const u=()=>{this.PressButton(e,d,0,!0)};a.addEventListener("pointerup",u),s.push(function(){window.removeEventListener("touchstart",i),a.removeEventListener("pointerenter",r),a.removeEventListener("pointerleave",p),a.removeEventListener("pointerdown",h),a.removeEventListener("pointerup",u),a.removeEventListener("pointercancel",c)})}else if(n.type==L.variable){const h=O({},n),u=this.AddDragControlListener(h,(g,P,w)=>{let v=g?this.buttonPressThreshold+1e-5:0;v+=n.directions[f.left]||n.directions[f.right]?Math.abs(P):0,v+=n.directions[f.up]||n.directions[f.down]?Math.abs(w):0,this.PressButton(e,n.buttonIndex,Math.min(v,1),g)});s.push(function(){window.removeEventListener("touchstart",i),a.removeEventListener("pointerenter",r),a.removeEventListener("pointerleave",p),a.removeEventListener("pointercancel",c),u()})}}this.emulatedGamepadsMetadata[e].removeButtonListenersFunc=()=>{s.forEach(n=>n())}}AddDisplayJoystickEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let s=[];for(let o=0;o<t.length;o++){const n=t[o],d=this.AddDragControlListener(n,(a,i,r)=>{n.xAxisIndex!==void 0&&this.MoveAxis(e,n.xAxisIndex,i),n.yAxisIndex!==void 0&&this.MoveAxis(e,n.yAxisIndex,r)});s.push(d)}this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc=()=>{s.forEach(o=>o())}}ClearDisplayButtonEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])==null?void 0:t.removeButtonListenersFunc)&&this.emulatedGamepadsMetadata[e].removeButtonListenersFunc()}ClearDisplayJoystickEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])==null?void 0:t.removeJoystickListenersFunc)&&this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc()}AddDragControlListener(e,t){let s={startX:0,startY:0},o=-1;const n=i=>{var r=i.pointerId;if(o===r){const p=e.directions[f.left]?-1:0,c=e.directions[f.right]?1:0,h=e.directions[f.up]?-1:0,u=e.directions[f.down]?1:0,g=i.clientX-s.startX,P=i.clientY-s.startY;let{x:w,y:v}=W(g,P,e.dragDistance);w=Math.max(Math.min(w,c),p),v=Math.max(Math.min(v,u),h),t(!0,w,v)}},d=i=>{o==i.pointerId&&(document.removeEventListener("pointermove",n,!1),document.removeEventListener("pointerup",d,!1),o=-1,t(!1,0,0))};e.tapTarget.addEventListener("pointerdown",i=>{i.preventDefault(),s.startX=i.clientX,s.startY=i.clientY,o=i.pointerId,e.lockTargetWhilePressed?e.tapTarget.setPointerCapture(i.pointerId):e.tapTarget.releasePointerCapture(i.pointerId),console.log("stick pointer down",e.tapTarget.hasPointerCapture(i.pointerId)),t(!0,0,0),document.addEventListener("pointermove",n,!1),document.addEventListener("pointerup",d,!1)});const a=i=>{i.changedTouches[0].target==e.tapTarget&&i.preventDefault()};return window.addEventListener("touchstart",a,{passive:!1}),function(){window.removeEventListener("touchstart",a),e.tapTarget.removeEventListener("pointerdown",n)}}cloneGamepad(e){if(!e)return e;const t=e.axes?e.axes.length:0,s=e.buttons?e.buttons.length:0,o={};for(let n in e)if(n==="axes"){const d=new Array(t);for(let a=0;a<t;a++)d[a]=Number(e.axes[a]);Object.defineProperty(o,"axes",{value:d,enumerable:!0})}else if(n==="buttons"){const d=new Array(s);for(let a=0;a<s;a++){const i=e.buttons[a];if(i==null)d[a]=i;else{const r=i.pressed,p=i.value,c=i.touched||!1;d[a]={pressed:r,value:p,touched:c}}}Object.defineProperty(o,"buttons",{value:d,enumerable:!0})}else Object.defineProperty(o,n,{get:()=>e[n],configurable:!0,enumerable:!0});return o.emulation||(o.emulation=G.real),o}nextEmptyEGpadIndex(e){let t=0;if(e)do{if(!this.emulatedGamepads[t])break;t++}while(t<this.emulatedGamepads.length);else{const s=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{if(!this.emulatedGamepads[t]&&this.patchedGpadToRealIndexMap[t]==null)break;console.log("nextEmptyEGpadIndex",t,!this.emulatedGamepads[t],this.patchedGpadToRealIndexMap[t]==null),t++}while(t<s)}return t}nextEmptyRealGpadIndex(e){let t=e;const s=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{const o=this.emulatedGamepadsMetadata[t],n=this.realGpadToPatchedIndexMap[t]==null&&this.patchedGpadToRealIndexMap[t]==null;if(!!o&&o.overlayMode||!o&&n)break;t++}while(t<s);return t}monkeyPatchGamepadEvents(){let e,t,s,o;window.hasOwnProperty("ongamepadconnected")&&(e=Object.getOwnPropertyDescriptor(window,"ongamepadconnected"),s=window.ongamepadconnected,window.ongamepadconnected=null,Object.defineProperty(window,"ongamepadconnected",{get:()=>function(a){},set:a=>{s=a},configurable:!0})),window.hasOwnProperty("ongamepaddisconnected")&&(t=Object.getOwnPropertyDescriptor(window,"ongamepaddisconnected"),o=window.ongamepaddisconnected,window.ongamepaddisconnected=null,Object.defineProperty(window,"ongamepaddisconnected",{get:()=>function(a){},set:a=>{s=a},configurable:!0}));const n=a=>{const i=a.gamepad;if(i&&i.emulation===void 0){a.stopImmediatePropagation();const r=this.cloneGamepad(a.gamepad),p=r.index,c=this.nextEmptyRealGpadIndex(p);this.realGpadToPatchedIndexMap[p]=c,this.patchedGpadToRealIndexMap[c]=p,Object.defineProperty(r,"index",{get:()=>c}),Object.defineProperty(r,"emulation",{get:()=>G.real}),this.realGamepadCount++,console.log(`real gamepad connected ${r.id} (${p}>${c})`,this.realGpadToPatchedIndexMap,this.emulatedGamepads,this.emulatedGamepadsMetadata);const h=new Event("gamepadconnected");h.gamepad=r,window.dispatchEvent(h),console.log("windowOngamepadconnected",s),s&&s.call(window,h)}};window.addEventListener("gamepadconnected",n);const d=a=>{const i=a.gamepad;if(i&&i.emulation===void 0){a.stopImmediatePropagation();const r=this.cloneGamepad(a.gamepad),p=this.realGpadToPatchedIndexMap[r.index]||r.index;Object.defineProperty(r,"index",{get:()=>p}),delete this.realGpadToPatchedIndexMap[r.index],delete this.patchedGpadToRealIndexMap[p],this.realGamepadCount--;const c=new Event("gamepaddisconnected");c.gamepad=r,window.dispatchEvent(c),o&&o.call(window,c)}};return window.addEventListener("gamepaddisconnected",d),function(){window.removeEventListener("gamepadconnected",n),window.hasOwnProperty("ongamepadconnected")&&(Object.defineProperty(window,"ongamepadconnected",e),window.ongamepadconnected=s),window.removeEventListener("gamepaddisconnected",d),window.hasOwnProperty("ongamepaddisconnected")&&(Object.defineProperty(window,"ongamepaddisconnected",t),window.ongamepaddisconnected=o)}}monkeyPatchGetGamepads(){const e=this;let t=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads;t&&(this.getNativeGamepads=t),navigator.getGamepads=function(){let s=[],o=t!=null?e.getNativeGamepads.apply(navigator):[];for(let d=0;d<o.length;d++){const a=o[d];if(!a)continue;let i=e.cloneGamepad(a),r=e.realGpadToPatchedIndexMap[i.index]||i.index;Object.defineProperty(i,"index",{get:()=>r}),s[r]=i}let n=e.emulatedGamepads;for(let d=0;d<n.length;d++){let a=s[d],i=n[d];if(i&&a){a.emulation=G.overlay;let r=Math.max(a.buttons.length,i.buttons.length);for(let c=0;c<r;c++){const h=i.buttons[c]||{touched:!1,pressed:!1,value:0},u=a.buttons[c]||{touched:!1,pressed:!1,value:0};s[d].buttons[c]={touched:h.touched||u.touched||!1,pressed:h.pressed||u.pressed||!1,value:Math.max(h.value,u.value)||0}}let p=Math.max(i.axes.length,a.axes.length);for(let c=0;c<p;c++){const h=i.axes[c]||0,u=a.axes[c]||0;s[d].axes[c]=Math.abs(h||0)>Math.abs(u||0)?h||0:u||0}}else i&&(i.emulation=G.emulated,i.timestamp=Math.floor(Date.now()/1e3),s[d]=e.cloneGamepad(i))}return s}}cleanup(){for(let e=0;e<this.emulatedGamepads.length;e++)this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);this.emulatedGamepads=[],this.undoEventPatch(),navigator.getGamepads=this.getNativeGamepads,y.instanceRunning=!1}};let H=y;m(H,"instanceRunning",!1);class U{constructor(e){m(this,"updateDelay");m(this,"axisDeadZone");m(this,"buttonConfigs");m(this,"lastStateOfGamepads");m(this,"changeMaskOfGamepads");m(this,"gamepadConnectListeners");m(this,"gamepadDisconnectListeners");m(this,"gamepadButtonChangeListeners");m(this,"gamepadAxisChangeListeners");this.updateDelay=e.updateDelay||0,this.axisDeadZone=e.axisDeadZone||0,this.buttonConfigs=e.buttonConfigs||[],this.lastStateOfGamepads=[],this.changeMaskOfGamepads=[],this.gamepadConnectListeners=[],this.gamepadDisconnectListeners=[],this.gamepadButtonChangeListeners=[],this.gamepadAxisChangeListeners=[],navigator.gamepadInputEmulation="gamepad",window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,navigator.getGamepads=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads,this.gamepadApiSupported()&&this.tickLoop()}set buttonsConfig(e){this.buttonConfigs=e}onGamepadConnect(e){this.gamepadConnectListeners.push(e),window.addEventListener("gamepadconnected",e,!0)}offGamepadConnect(e){this.gamepadConnectListeners=this.gamepadConnectListeners.filter(t=>t!==e),window.removeEventListener("gamepadconnected",e,!0)}onGamepadDisconnect(e){this.gamepadDisconnectListeners.push(e),window.addEventListener("gamepaddisconnected",e,!0)}offGamepadDisconnect(e){this.gamepadDisconnectListeners=this.gamepadDisconnectListeners.filter(t=>t!==e),window.removeEventListener("gamepaddisconnected",e,!0)}onGamepadAxisChange(e){return this.gamepadAxisChangeListeners.push(e),e}offGamepadAxisChange(e){this.gamepadAxisChangeListeners=this.gamepadAxisChangeListeners.filter(t=>t!==e)}onGamepadButtonChange(e){return this.gamepadButtonChangeListeners.push(e),e}offGamepadButtonChange(e){this.gamepadButtonChangeListeners=this.gamepadButtonChangeListeners.filter(t=>t!==e)}gamepadApiSupported(){return!!navigator.getGamepads&&!!navigator.getGamepads()}tickLoop(){this.checkForGamepadChanges(),this.updateDelay==0?requestAnimationFrame(this.tickLoop.bind(this)):setTimeout(()=>{requestAnimationFrame(this.tickLoop.bind(this))},this.updateDelay)}checkForGamepadChanges(){let e=navigator.getGamepads();for(var t=0;t<e.length;t++){let s=e[t];!s||(this.lastStateOfGamepads[t]||(this.lastStateOfGamepads[t]=s),this.checkForAxisChanges(t,s),this.checkForButtonChanges(t,s),this.lastStateOfGamepads[t]=s)}}checkForAxisChanges(e,t){let s=t.axes;if(s.length==0)return;let n=this.lastStateOfGamepads[e].axes||[],d=[],a,i=!1;for(a=0;a<s.length;a++){let r=s[a]||0,p=n[a]||0;!(Math.abs(r)<this.axisDeadZone)&&r!=p?(d[a]=!0,i=!0):d[a]=!1}i&&this.gamepadAxisChangeListeners.forEach(r=>r(e,t,d))}checkForButtonChanges(e,t){let s=t.buttons;if(s.length==0)return;const n=this.lastStateOfGamepads[e].buttons||s;let d=[],a,i=!1;for(a=0;a<s.length;a++){let r=!1;const p=s[a]||{pressed:!1,value:0,touched:!1},c=n[a]||{pressed:!1,value:0,touched:!1},h=this.buttonConfigs[a]||{},u={};p.touched&&!c.touched?(u.touchDown=!0,r=!0):!p.touched&&c.touched&&(u.touchUp=!0,r=!0),p.pressed&&!c.pressed?(u.pressed=!0,r=!0):!p.pressed&&c.pressed&&(u.released=!0,r=!0),h.fireWhileHolding&&p.pressed&&c.pressed&&(u.heldDown=!0,r=!0),p.value!=c.value&&(u.valueChanged=!0,r=!0),r?(i=!0,d[a]=u):d[a]=!1}i&&this.gamepadButtonChangeListeners.forEach(r=>r(e,t,d))}}var E,b,D,A,R;class Y{constructor(e,t){x(this,A);m(this,"config");m(this,"apiWrapper");x(this,E,void 0);x(this,b,void 0);m(this,"defaultJoystickDisplayFunction",(e,t,s)=>{const o=e.movementRange;if(e.joystickElement.style.transform=`translate(${t*o}px,${s*o}px)`,e.highlights&&this.config.moveDirectionHighlightClass){const n=e.highlights[f.up],d=e.highlights[f.down],a=e.highlights[f.left],i=e.highlights[f.right];n&&s<-.1?n.classList.add(this.config.moveDirectionHighlightClass||""):n&&n.classList.remove(this.config.moveDirectionHighlightClass||""),d&&s>.1?d.classList.add(this.config.moveDirectionHighlightClass||""):d&&d.classList.remove(this.config.moveDirectionHighlightClass||""),a&&t<-.1?a.classList.add(this.config.moveDirectionHighlightClass||""):a&&a.classList.remove(this.config.moveDirectionHighlightClass||""),i&&t>.1?i.classList.add(this.config.moveDirectionHighlightClass||""):i&&i.classList.remove(this.config.moveDirectionHighlightClass||"")}});m(this,"defaultButtonDisplayFunction",(e,t,s,o,n,d)=>{const a=e.highlight;if(this.config.touchedHighlightClass&&a&&(n.touchDown?a.classList.add(this.config.touchedHighlightClass):n.touchUp&&a.classList.remove(this.config.touchedHighlightClass)),this.config.pressedHighlightClass&&a&&(n.pressed?a.classList.add(this.config.pressedHighlightClass):n.released&&a.classList.remove(this.config.pressedHighlightClass)),e.type==L.variable){const i=e.directionHighlight;if(this.config.moveDirectionHighlightClass&&i&&(n.pressed?i.classList.add(this.config.moveDirectionHighlightClass):n.released&&i.classList.remove(this.config.moveDirectionHighlightClass)),e.buttonElement){const r=e.direction==f.left||e.direction==f.right,p=e.direction==f.right||e.direction==f.down;e.buttonElement.style.transform=`translate${r?"X":"Y"}(${p?"":"-"}${t*e.movementRange}px)`}}});x(this,D,(e,t,s)=>{if(e!=this.config.gamepadIndex)return;const o=this.config.buttons;for(let n=0;n<o.length;n++){const d=s[n];if(!d||Object.keys(d).length==0)continue;const a=o[n],i=t.buttons[n].value,r=t.buttons[n].touched,p=t.buttons[n].pressed;this.config.buttonDisplayFunction?this.config.buttonDisplayFunction(a,i,r,p,d,n):this.defaultButtonDisplayFunction(a,i,r,p,d,n)}});this.config=e,this.apiWrapper=t||new U({buttonConfigs:[],updateDelay:0}),k(this,E,this.apiWrapper.onGamepadButtonChange(C(this,D).bind(this))),k(this,b,this.apiWrapper.onGamepadAxisChange(I(this,A,R).bind(this)))}cleanup(){this.apiWrapper.offGamepadButtonChange(C(this,E)),this.apiWrapper.offGamepadAxisChange(C(this,b))}}E=new WeakMap,b=new WeakMap,D=new WeakMap,A=new WeakSet,R=function(e,t,s){if(e!=this.config.gamepadIndex)return;const o=this.config.sticks;for(let n=0;n<o.length;n++){const d=o[n];if(d.xAxisIndex!==void 0&&s[d.xAxisIndex]||d.yAxisIndex!==void 0&&s[d.yAxisIndex]){const a=t.axes,i=d.xAxisIndex!==void 0&&a[d.xAxisIndex]||0,r=d.yAxisIndex!==void 0&&a[d.yAxisIndex]||0;this.config.joystickDisplayFunction?this.config.joystickDisplayFunction(d,i,r):this.defaultJoystickDisplayFunction(d,i,r)}}};export{X as D,H as G,U as a,L as b,f as c,Y as d,q as e,G as g};
