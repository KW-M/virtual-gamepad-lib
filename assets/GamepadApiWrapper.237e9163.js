var A=Object.defineProperty,D=Object.defineProperties;var T=Object.getOwnPropertyDescriptors;var M=Object.getOwnPropertySymbols;var O=Object.prototype.hasOwnProperty,k=Object.prototype.propertyIsEnumerable;var y=(p,e,t)=>e in p?A(p,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):p[e]=t,E=(p,e)=>{for(var t in e||(e={}))O.call(e,t)&&y(p,t,e[t]);if(M)for(var t of M(e))k.call(e,t)&&y(p,t,e[t]);return p},P=(p,e)=>D(p,T(e));var h=(p,e,t)=>(y(p,typeof e!="symbol"?e+"":e,t),t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))n(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const r of s.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&n(r)}).observe(document,{childList:!0,subtree:!0});function t(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerpolicy&&(s.referrerPolicy=o.referrerpolicy),o.crossorigin==="use-credentials"?s.credentials="include":o.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(o){if(o.ep)return;o.ep=!0;const s=t(o);fetch(o.href,s)}})();var g=(p=>(p.up="up",p.down="down",p.left="left",p.right="right",p))(g||{}),C=(p=>(p.onOff="onOff",p.variable="variable",p))(C||{}),G=(p=>(p.real="real",p.emulated="emulated",p.overlay="overlay",p))(G||{});function B(p,e,t){const n=Math.sqrt(p*p+e*e);return n>t?{x:p/n,y:e/n}:{x:p/t,y:e/t}}function I(p){document.querySelectorAll(p).forEach(t=>{if(t instanceof SVGGraphicsElement){t.getAttribute("transform")&&console.warn("Setting Transform origin on an element that already has a transform attribute. This may break the transform!",t);const n=t.getBBox();t.style.transformOrigin=`${n.x+n.width/2}px ${n.y+n.height/2}px`}else if(t instanceof HTMLElement){console.warn("Setting Transform origin on an element that is not an SVG element. This may break the transform!",t);const n=t.getBoundingClientRect();t.style.transformOrigin=`${n.width/2}px ${n.height/2}px`}})}const S=18,F=4,x=class{constructor(e){h(this,"getNativeGamepads",()=>[]);h(this,"buttonPressThreshold",.1);h(this,"realGamepadCount",0);h(this,"realGpadToPatchedIndexMap",[]);h(this,"patchedGpadToRealIndexMap",[]);h(this,"emulatedGamepads",[]);h(this,"emulatedGamepadsMetadata",[]);h(this,"undoEventPatch",()=>{});if(this.buttonPressThreshold=e||this.buttonPressThreshold,x.instanceRunning)throw new Error("Only one GamepadEmulator instance may exist at a time!");x.instanceRunning=!0,this.undoEventPatch=this.monkeyPatchGamepadEvents(),this.monkeyPatchGetGamepads()}AddEmulatedGamepad(e,t,n=S,o=F){if((e===-1||!e&&e!==0)&&(e=this.nextEmptyEGpadIndex(t)),this.emulatedGamepads[e])return!1;const s={emulation:G.emulated,connected:!0,timestamp:Math.floor(Date.now()/1e3),displayId:"Emulated Gamepad "+e,id:"Emulated Gamepad "+e+" (Xinput STANDARD GAMEPAD)",mapping:"standard",index:e,buttons:new Array(n).fill({pressed:!1,value:0,touched:!1},0,n),axes:new Array(o).fill(0,0,o),hapticActuators:[]};this.emulatedGamepads[e]=s,this.emulatedGamepadsMetadata[e]={overlayMode:t};const r=new Event("gamepadconnected");return r.gamepad=s,window.dispatchEvent(r),s}RemoveEmulatedGamepad(e){this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);var t=this.emulatedGamepads[e];if(t){delete this.emulatedGamepads[e],delete this.emulatedGamepadsMetadata[e];const n=P(E({},t),{connected:!1,timestamp:Math.floor(Date.now()/1e3)}),o=new Event("gamepaddisconnected");o.gamepad=n,window.dispatchEvent(o)}else console.warn("Error: removing emulated gamepad. No emulated gamepad exists at index "+e)}PressButton(e,t,n,o){if(this.emulatedGamepads[e]===void 0)throw new Error("Error: PressButton() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");var s=n>this.buttonPressThreshold;this.emulatedGamepads[e].buttons[t]={pressed:s,value:n||0,touched:s||o||!1}}MoveAxis(e,t,n){if(!this.emulatedGamepads[e])throw new Error("Error: MoveAxis() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");this.emulatedGamepads[e].axes[t]=n}AddDisplayButtonEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let n=[];for(var o=0;o<t.length;o++){const s=t[o],r=s.buttonIndex,a=s.tapTarget;if(!a){console.warn("AddDisplayButtonEventListeners() - no tap target in button config "+r+", skipping...");continue}const i=m=>{m.changedTouches[0].target==a&&m.preventDefault()};window.addEventListener("touchstart",i,{passive:!1});const d=m=>{const u=m.buttons==1?1:0;(!s.lockTargetWhilePressed||u==0)&&this.PressButton(e,r,u,!0)};a.addEventListener("pointerenter",d);const c=m=>{const u=m.buttons==1?1:0;(!s.lockTargetWhilePressed||u==0)&&this.PressButton(e,r,0,!1)};a.addEventListener("pointerleave",c);const l=m=>{};if(a.addEventListener("pointercancel",l),s.type==C.onOff){const m=f=>{f.preventDefault(),this.PressButton(e,r,1,!0),s.lockTargetWhilePressed?a.setPointerCapture(f.pointerId):a.releasePointerCapture(f.pointerId),console.log("on/off pointer down",a.hasPointerCapture(f.pointerId))};a.addEventListener("pointerdown",m);const u=()=>{this.PressButton(e,r,0,!0)};a.addEventListener("pointerup",u),n.push(function(){window.removeEventListener("touchstart",i),a.removeEventListener("pointerenter",d),a.removeEventListener("pointerleave",c),a.removeEventListener("pointerdown",m),a.removeEventListener("pointerup",u),a.removeEventListener("pointercancel",l)})}else if(s.type==C.variable){const m=E({},s),u=this.AddDragControlListener(m,(f,L,w)=>{let v=f?this.buttonPressThreshold+1e-5:0;v+=s.directions[g.left]||s.directions[g.right]?Math.abs(L):0,v+=s.directions[g.up]||s.directions[g.down]?Math.abs(w):0,this.PressButton(e,s.buttonIndex,Math.min(v,1),f)});n.push(function(){window.removeEventListener("touchstart",i),a.removeEventListener("pointerenter",d),a.removeEventListener("pointerleave",c),a.removeEventListener("pointercancel",l),u()})}}this.emulatedGamepadsMetadata[e].removeButtonListenersFunc=()=>{n.forEach(s=>s())}}AddDisplayJoystickEventListeners(e,t){if(!this.emulatedGamepads[e])throw new Error("Error: AddDisplayJoystickEventListeners() - no emulated gamepad at index "+e+", pass a valid index, or call AddEmulatedGamepad() first to create an emulated gamepad at that index");let n=[];for(let o=0;o<t.length;o++){const s=t[o];if(s.tapTarget==null){console.warn(`AddDisplayJoystickEventListeners() - no tap target in joystick config ${o}, skipping...`);continue}const r=this.AddDragControlListener(s,(a,i,d)=>{s.xAxisIndex!==void 0&&this.MoveAxis(e,s.xAxisIndex,i),s.yAxisIndex!==void 0&&this.MoveAxis(e,s.yAxisIndex,d)});n.push(r)}this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc=()=>{n.forEach(o=>o())}}ClearDisplayButtonEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])==null?void 0:t.removeButtonListenersFunc)&&this.emulatedGamepadsMetadata[e].removeButtonListenersFunc()}ClearDisplayJoystickEventListeners(e){var t;this.emulatedGamepadsMetadata[e]&&((t=this.emulatedGamepadsMetadata[e])==null?void 0:t.removeJoystickListenersFunc)&&this.emulatedGamepadsMetadata[e].removeJoystickListenersFunc()}AddDragControlListener(e,t){let n={startX:0,startY:0},o=-1;const s=i=>{var d=i.pointerId;if(o===d){const c=e.directions[g.left]?-1:0,l=e.directions[g.right]?1:0,m=e.directions[g.up]?-1:0,u=e.directions[g.down]?1:0,f=i.clientX-n.startX,L=i.clientY-n.startY;let{x:w,y:v}=B(f,L,e.dragDistance);w=Math.max(Math.min(w,l),c),v=Math.max(Math.min(v,u),m),t(!0,w,v)}},r=i=>{o==i.pointerId&&(document.removeEventListener("pointermove",s,!1),document.removeEventListener("pointerup",r,!1),o=-1,t(!1,0,0))};e.tapTarget.addEventListener("pointerdown",i=>{i.preventDefault(),n.startX=i.clientX,n.startY=i.clientY,o=i.pointerId,e.lockTargetWhilePressed?e.tapTarget.setPointerCapture(i.pointerId):e.tapTarget.releasePointerCapture(i.pointerId),console.log("stick pointer down",e.tapTarget.hasPointerCapture(i.pointerId)),t(!0,0,0),document.addEventListener("pointermove",s,!1),document.addEventListener("pointerup",r,!1)});const a=i=>{i.changedTouches[0].target==e.tapTarget&&i.preventDefault()};return window.addEventListener("touchstart",a,{passive:!1}),function(){window.removeEventListener("touchstart",a),e.tapTarget.removeEventListener("pointerdown",s)}}cloneGamepad(e){if(!e)return e;const t=e.axes?e.axes.length:0,n=e.buttons?e.buttons.length:0,o={};for(let s in e)if(s==="axes"){const r=new Array(t);for(let a=0;a<t;a++)r[a]=Number(e.axes[a]);Object.defineProperty(o,"axes",{value:r,enumerable:!0})}else if(s==="buttons"){const r=new Array(n);for(let a=0;a<n;a++){const i=e.buttons[a];if(i==null)r[a]=i;else{const d=i.pressed,c=i.value,l=i.touched||!1;r[a]={pressed:d,value:c,touched:l}}}Object.defineProperty(o,"buttons",{value:r,enumerable:!0})}else Object.defineProperty(o,s,{get:()=>e[s],configurable:!0,enumerable:!0});return o.emulation||(o.emulation=G.real),o}nextEmptyEGpadIndex(e){let t=0;if(e)do{if(!this.emulatedGamepads[t])break;t++}while(t<this.emulatedGamepads.length);else{const n=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{if(!this.emulatedGamepads[t]&&this.patchedGpadToRealIndexMap[t]==null)break;console.log("nextEmptyEGpadIndex",t,!this.emulatedGamepads[t],this.patchedGpadToRealIndexMap[t]==null),t++}while(t<n)}return t}nextEmptyRealGpadIndex(e){let t=e;const n=Math.max(this.emulatedGamepads.length,this.patchedGpadToRealIndexMap.length);do{const o=this.emulatedGamepadsMetadata[t],s=this.realGpadToPatchedIndexMap[t]==null&&this.patchedGpadToRealIndexMap[t]==null;if(!!o&&o.overlayMode||!o&&s)break;t++}while(t<n);return t}monkeyPatchGamepadEvents(){let e,t,n,o;window.hasOwnProperty("ongamepadconnected")&&(e=Object.getOwnPropertyDescriptor(window,"ongamepadconnected"),n=window.ongamepadconnected,window.ongamepadconnected=null,Object.defineProperty(window,"ongamepadconnected",{get:()=>function(a){},set:a=>{n=a},configurable:!0})),window.hasOwnProperty("ongamepaddisconnected")&&(t=Object.getOwnPropertyDescriptor(window,"ongamepaddisconnected"),o=window.ongamepaddisconnected,window.ongamepaddisconnected=null,Object.defineProperty(window,"ongamepaddisconnected",{get:()=>function(a){},set:a=>{n=a},configurable:!0}));const s=a=>{const i=a.gamepad;if(i&&i.emulation===void 0){a.stopImmediatePropagation();const d=this.cloneGamepad(a.gamepad),c=d.index,l=this.nextEmptyRealGpadIndex(c);this.realGpadToPatchedIndexMap[c]=l,this.patchedGpadToRealIndexMap[l]=c,Object.defineProperty(d,"index",{get:()=>l}),Object.defineProperty(d,"emulation",{get:()=>G.real}),this.realGamepadCount++,console.log(`real gamepad connected ${d.id} (${c}>${l})`,this.realGpadToPatchedIndexMap,this.emulatedGamepads,this.emulatedGamepadsMetadata);const m=new Event("gamepadconnected");m.gamepad=d,window.dispatchEvent(m),console.log("windowOngamepadconnected",n),n&&n.call(window,m)}};window.addEventListener("gamepadconnected",s);const r=a=>{const i=a.gamepad;if(i&&i.emulation===void 0){a.stopImmediatePropagation();const d=this.cloneGamepad(a.gamepad),c=this.realGpadToPatchedIndexMap[d.index]||d.index;Object.defineProperty(d,"index",{get:()=>c}),delete this.realGpadToPatchedIndexMap[d.index],delete this.patchedGpadToRealIndexMap[c],this.realGamepadCount--;const l=new Event("gamepaddisconnected");l.gamepad=d,window.dispatchEvent(l),o&&o.call(window,l)}};return window.addEventListener("gamepaddisconnected",r),function(){window.removeEventListener("gamepadconnected",s),window.hasOwnProperty("ongamepadconnected")&&(Object.defineProperty(window,"ongamepadconnected",e),window.ongamepadconnected=n),window.removeEventListener("gamepaddisconnected",r),window.hasOwnProperty("ongamepaddisconnected")&&(Object.defineProperty(window,"ongamepaddisconnected",t),window.ongamepaddisconnected=o)}}monkeyPatchGetGamepads(){const e=this;let t=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads;t&&(this.getNativeGamepads=t),navigator.getGamepads=function(){let n=[],o=t!=null?e.getNativeGamepads.apply(navigator):[];for(let r=0;r<o.length;r++){const a=o[r];if(!a)continue;let i=e.cloneGamepad(a),d=e.realGpadToPatchedIndexMap[i.index]||i.index;Object.defineProperty(i,"index",{get:()=>d}),n[d]=i}let s=e.emulatedGamepads;for(let r=0;r<s.length;r++){let a=n[r],i=s[r];if(i&&a){a.emulation=G.overlay;let d=Math.max(a.buttons.length,i.buttons.length);for(let l=0;l<d;l++){const m=i.buttons[l]||{touched:!1,pressed:!1,value:0},u=a.buttons[l]||{touched:!1,pressed:!1,value:0};n[r].buttons[l]={touched:m.touched||u.touched||!1,pressed:m.pressed||u.pressed||!1,value:Math.max(m.value,u.value)||0}}let c=Math.max(i.axes.length,a.axes.length);for(let l=0;l<c;l++){const m=i.axes[l]||0,u=a.axes[l]||0;n[r].axes[l]=Math.abs(m||0)>Math.abs(u||0)?m||0:u||0}}else i&&(i.emulation=G.emulated,i.timestamp=Math.floor(Date.now()/1e3),n[r]=e.cloneGamepad(i))}return n}}cleanup(){for(let e=0;e<this.emulatedGamepads.length;e++)this.ClearDisplayButtonEventListeners(e),this.ClearDisplayJoystickEventListeners(e);this.emulatedGamepads=[],this.undoEventPatch(),navigator.getGamepads=this.getNativeGamepads,x.instanceRunning=!1}};let b=x;h(b,"instanceRunning",!1);class N{constructor(e){h(this,"updateDelay");h(this,"axisDeadZone");h(this,"buttonConfigs");h(this,"lastStateOfGamepads");h(this,"changeMaskOfGamepads");h(this,"gamepadConnectListeners");h(this,"gamepadDisconnectListeners");h(this,"gamepadButtonChangeListeners");h(this,"gamepadAxisChangeListeners");this.updateDelay=e.updateDelay||0,this.axisDeadZone=e.axisDeadZone||0,this.buttonConfigs=e.buttonConfigs||[],this.lastStateOfGamepads=[],this.changeMaskOfGamepads=[],this.gamepadConnectListeners=[],this.gamepadDisconnectListeners=[],this.gamepadButtonChangeListeners=[],this.gamepadAxisChangeListeners=[],navigator.gamepadInputEmulation="gamepad",window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,navigator.getGamepads=navigator.getGamepads||navigator.webkitGetGamepads||navigator.mozGetGamepads||navigator.msGetGamepads,this.gamepadApiSupported()&&this.tickLoop()}set buttonsConfig(e){this.buttonConfigs=e}onGamepadConnect(e){this.gamepadConnectListeners.push(e),window.addEventListener("gamepadconnected",e,!0)}offGamepadConnect(e){this.gamepadConnectListeners=this.gamepadConnectListeners.filter(t=>t!==e),window.removeEventListener("gamepadconnected",e,!0)}onGamepadDisconnect(e){this.gamepadDisconnectListeners.push(e),window.addEventListener("gamepaddisconnected",e,!0)}offGamepadDisconnect(e){this.gamepadDisconnectListeners=this.gamepadDisconnectListeners.filter(t=>t!==e),window.removeEventListener("gamepaddisconnected",e,!0)}onGamepadAxisChange(e){return this.gamepadAxisChangeListeners.push(e),e}offGamepadAxisChange(e){this.gamepadAxisChangeListeners=this.gamepadAxisChangeListeners.filter(t=>t!==e)}onGamepadButtonChange(e){return this.gamepadButtonChangeListeners.push(e),e}offGamepadButtonChange(e){this.gamepadButtonChangeListeners=this.gamepadButtonChangeListeners.filter(t=>t!==e)}gamepadApiSupported(){return!!navigator.getGamepads&&!!navigator.getGamepads()}tickLoop(){this.checkForGamepadChanges(),this.updateDelay==0?requestAnimationFrame(this.tickLoop.bind(this)):setTimeout(()=>{requestAnimationFrame(this.tickLoop.bind(this))},this.updateDelay)}checkForGamepadChanges(){let e=navigator.getGamepads();for(var t=0;t<e.length;t++){let n=e[t];!n||(this.lastStateOfGamepads[t]||(this.lastStateOfGamepads[t]=n),this.checkForAxisChanges(t,n),this.checkForButtonChanges(t,n),this.lastStateOfGamepads[t]=n)}}checkForAxisChanges(e,t){let n=t.axes;if(n.length==0)return;let s=this.lastStateOfGamepads[e].axes||[],r=[],a,i=!1;for(a=0;a<n.length;a++){let d=n[a]||0,c=s[a]||0;if(d!=c){if(Math.abs(d)<this.axisDeadZone&&Math.abs(c)<this.axisDeadZone)continue;r[a]=!0,i=!0}else r[a]=!1}i&&this.gamepadAxisChangeListeners.forEach(d=>d(e,t,r))}checkForButtonChanges(e,t){let n=t.buttons;if(n.length==0)return;const s=this.lastStateOfGamepads[e].buttons||n;let r=[],a,i=!1;for(a=0;a<n.length;a++){let d=!1;const c=n[a]||{pressed:!1,value:0,touched:!1},l=s[a]||{pressed:!1,value:0,touched:!1},m=this.buttonConfigs[a]||{},u={};c.touched&&!l.touched?(u.touchDown=!0,d=!0):!c.touched&&l.touched&&(u.touchUp=!0,d=!0),c.pressed&&!l.pressed?(u.pressed=!0,d=!0):!c.pressed&&l.pressed&&(u.released=!0,d=!0),m.fireWhileHolding&&c.pressed&&l.pressed&&(u.heldDown=!0,d=!0),c.value!=l.value&&(u.valueChanged=!0,d=!0),d?(i=!0,r[a]=u):r[a]=!1}i&&this.gamepadButtonChangeListeners.forEach(d=>d(e,t,r))}}export{S as D,b as G,N as a,C as b,g as c,I as d,F as e,G as g};
